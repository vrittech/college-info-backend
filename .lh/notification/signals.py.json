{
    "sourceFile": "notification/signals.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 47,
            "patches": [
                {
                    "date": 1739685589715,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739685597309,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n from notifications.signals import notify\n from django.apps import apps\n-from django.contrib.auth.models import User\n+from accounts.models import CustomUser as User\n \n # ðŸ“Œ Generic function to send notifications\n def send_notification(instance, action, recipient=None, additional_info=None):\n     \"\"\" Sends notifications for all CRUD actions \"\"\"\n"
                },
                {
                    "date": 1739685644955,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,19 +1,27 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n from notifications.signals import notify\n from django.apps import apps\n-from accounts.models import CustomUser as User\n+from django.contrib.auth.models import User\n \n # ðŸ“Œ Generic function to send notifications\n def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions \"\"\"\n-    actor = instance.user if hasattr(instance, 'user') else None  # The actor (could be the creator or user)\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    # For example, assume that each model has a `user` field indicating the owner or relevant user\n+    if hasattr(instance, 'user'):  # Check if the model has a `user` field (modify this as needed)\n+        recipient = instance.user  # The user associated with this instance (model)\n     \n+    # If there's no `user` attribute, you can customize how you determine the recipient\n+    else:\n+        # Example: if there's a creator or owner field, you can notify that user instead\n+        # recipient = instance.creator or instance.owner (based on your model design)\n+        pass\n+    \n     if not recipient:\n-        recipient = User.objects.all()  # You can customize this to target specific users\n-    \n-    # Message template based on action\n+        return  # If there's no recipient defined, don't send any notifications\n+\n+    # Construct the message based on the action\n     if action == 'created':\n         verb = \"created\"\n         description = f\"A new {instance.__class__.__name__} was created.\"\n     elif action == 'updated':\n@@ -26,11 +34,11 @@\n     # Add additional info to description if available\n     if additional_info:\n         description += f\" Additional Info: {additional_info}\"\n \n-    # Send notification\n+    # Send notification to the recipient (only to the related user)\n     notify.send(\n-        actor,  # The user who triggered the action (optional)\n+        instance.user,  # Actor (the user who triggered the action)\n         recipient=recipient,\n         verb=verb,\n         description=description\n     )\n"
                },
                {
                    "date": 1739685652594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n from notifications.signals import notify\n from django.apps import apps\n-from django.contrib.auth.models import User\n+from \n \n # ðŸ“Œ Generic function to send notifications\n def send_notification(instance, action, recipient=None, additional_info=None):\n     \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n"
                },
                {
                    "date": 1739685658740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n from notifications.signals import notify\n from django.apps import apps\n-from \n+from accounts.models import CustomUser as User\n \n # ðŸ“Œ Generic function to send notifications\n def send_notification(instance, action, recipient=None, additional_info=None):\n     \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n"
                },
                {
                    "date": 1739685735807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n from notifications.signals import notify\n+from django.contrib.auth.models import User\n from django.apps import apps\n-from accounts.models import CustomUser as User\n \n # ðŸ“Œ Generic function to send notifications\n def send_notification(instance, action, recipient=None, additional_info=None):\n     \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n@@ -13,14 +13,13 @@\n     \n     # If there's no `user` attribute, you can customize how you determine the recipient\n     else:\n         # Example: if there's a creator or owner field, you can notify that user instead\n-        # recipient = instance.creator or instance.owner (based on your model design)\n         pass\n     \n     if not recipient:\n         return  # If there's no recipient defined, don't send any notifications\n-\n+    \n     # Construct the message based on the action\n     if action == 'created':\n         verb = \"created\"\n         description = f\"A new {instance.__class__.__name__} was created.\"\n@@ -34,15 +33,27 @@\n     # Add additional info to description if available\n     if additional_info:\n         description += f\" Additional Info: {additional_info}\"\n \n-    # Send notification to the recipient (only to the related user)\n-    notify.send(\n-        instance.user,  # Actor (the user who triggered the action)\n-        recipient=recipient,\n-        verb=verb,\n-        description=description\n-    )\n+    # Check if the actor (user) is a superadmin\n+    if instance.user and instance.user.is_superuser:\n+        # If the actor is a superadmin, send notifications to all users\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            notify.send(\n+                instance.user,  # Actor (superadmin who triggered the action)\n+                recipient=user,  # All users will be notified\n+                verb=verb,\n+                description=description\n+            )\n+    else:\n+        # Send notification to the specific recipient\n+        notify.send(\n+            instance.user,  # Actor (the user who triggered the action)\n+            recipient=recipient,\n+            verb=verb,\n+            description=description\n+        )\n \n # ðŸ“Œ Dynamically connect signals for all models\n def connect_signals():\n     for model in apps.get_models():  # Get all models in the project\n"
                },
                {
                    "date": 1739685871079,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,79 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.contrib.auth.models import User\n+from django.apps import apps\n+\n+# ðŸ“Œ Generic function to send notifications\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    # For example, assume that each model has a `user` field indicating the owner or relevant user\n+    if hasattr(instance, 'user'):  # Check if the model has a `user` field (modify this as needed)\n+        recipient = instance.user  # The user associated with this instance (model)\n+    \n+    # If there's no `user` attribute, you can customize how you determine the recipient\n+    else:\n+        # Example: if there's a creator or owner field, you can notify that user instead\n+        pass\n+    \n+    if not recipient:\n+        return  # If there's no recipient defined, don't send any notifications\n+    \n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {instance.__class__.__name__} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {instance.__class__.__name__} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {instance.__class__.__name__} was deleted.\"\n+\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Check if the actor (user) is a superadmin\n+    if instance.user and instance.user.is_superuser:\n+        # If the actor is a superadmin, send notifications to all users\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            notify.send(\n+                instance.user,  # Actor (superadmin who triggered the action)\n+                recipient=user,  # All users will be notified\n+                verb=verb,\n+                description=description\n+            )\n+    else:\n+        # Send notification to the specific recipient\n+        notify.send(\n+            instance.user,  # Actor (the user who triggered the action)\n+            recipient=recipient,\n+            verb=verb,\n+            description=description\n+        )\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Get all models in the project\n+        if hasattr(model, 'user'):  # Filter models with 'user' field (you can modify this)\n+            # Handle post_save (creation and updates)\n+            post_save.connect(handle_save, sender=model)\n+\n+            # Handle post_delete (deletion)\n+            post_delete.connect(handle_delete, sender=model)\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739685877525,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,79 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.contrib.auth.models import User\n+from django.apps import apps\n+\n+# ðŸ“Œ Generic function to send notifications\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    # For example, assume that each model has a `user` field indicating the owner or relevant user\n+    if hasattr(instance, 'user'):  # Check if the model has a `user` field (modify this as needed)\n+        recipient = instance.user  # The user associated with this instance (model)\n+    \n+    # If there's no `user` attribute, you can customize how you determine the recipient\n+    else:\n+        # Example: if there's a creator or owner field, you can notify that user instead\n+        pass\n+    \n+    if not recipient:\n+        return  # If there's no recipient defined, don't send any notifications\n+    \n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {instance.__class__.__name__} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {instance.__class__.__name__} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {instance.__class__.__name__} was deleted.\"\n+\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Check if the actor (user) is a superadmin\n+    if instance.user and instance.user.is_superuser:\n+        # If the actor is a superadmin, send notifications to all users\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            notify.send(\n+                instance.user,  # Actor (superadmin who triggered the action)\n+                recipient=user,  # All users will be notified\n+                verb=verb,\n+                description=description\n+            )\n+    else:\n+        # Send notification to the specific recipient\n+        notify.send(\n+            instance.user,  # Actor (the user who triggered the action)\n+            recipient=recipient,\n+            verb=verb,\n+            description=description\n+        )\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Get all models in the project\n+        if hasattr(model, 'user'):  # Filter models with 'user' field (you can modify this)\n+            # Handle post_save (creation and updates)\n+            post_save.connect(handle_save, sender=model)\n+\n+            # Handle post_delete (deletion)\n+            post_delete.connect(handle_delete, sender=model)\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739685892323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,162 +76,4 @@\n     send_notification(instance, action='deleted', recipient=None)\n \n # ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.contrib.auth.models import User\n-from django.apps import apps\n-\n-# ðŸ“Œ Generic function to send notifications\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    # For example, assume that each model has a `user` field indicating the owner or relevant user\n-    if hasattr(instance, 'user'):  # Check if the model has a `user` field (modify this as needed)\n-        recipient = instance.user  # The user associated with this instance (model)\n-    \n-    # If there's no `user` attribute, you can customize how you determine the recipient\n-    else:\n-        # Example: if there's a creator or owner field, you can notify that user instead\n-        pass\n-    \n-    if not recipient:\n-        return  # If there's no recipient defined, don't send any notifications\n-    \n-    # Construct the message based on the action\n-    if action == 'created':\n-        verb = \"created\"\n-        description = f\"A new {instance.__class__.__name__} was created.\"\n-    elif action == 'updated':\n-        verb = \"updated\"\n-        description = f\"The {instance.__class__.__name__} was updated.\"\n-    elif action == 'deleted':\n-        verb = \"deleted\"\n-        description = f\"The {instance.__class__.__name__} was deleted.\"\n-\n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Check if the actor (user) is a superadmin\n-    if instance.user and instance.user.is_superuser:\n-        # If the actor is a superadmin, send notifications to all users\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            notify.send(\n-                instance.user,  # Actor (superadmin who triggered the action)\n-                recipient=user,  # All users will be notified\n-                verb=verb,\n-                description=description\n-            )\n-    else:\n-        # Send notification to the specific recipient\n-        notify.send(\n-            instance.user,  # Actor (the user who triggered the action)\n-            recipient=recipient,\n-            verb=verb,\n-            description=description\n-        )\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Get all models in the project\n-        if hasattr(model, 'user'):  # Filter models with 'user' field (you can modify this)\n-            # Handle post_save (creation and updates)\n-            post_save.connect(handle_save, sender=model)\n-\n-            # Handle post_delete (deletion)\n-            post_delete.connect(handle_delete, sender=model)\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.contrib.auth.models import User\n-from django.apps import apps\n-\n-# ðŸ“Œ Generic function to send notifications\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    # For example, assume that each model has a `user` field indicating the owner or relevant user\n-    if hasattr(instance, 'user'):  # Check if the model has a `user` field (modify this as needed)\n-        recipient = instance.user  # The user associated with this instance (model)\n-    \n-    # If there's no `user` attribute, you can customize how you determine the recipient\n-    else:\n-        # Example: if there's a creator or owner field, you can notify that user instead\n-        pass\n-    \n-    if not recipient:\n-        return  # If there's no recipient defined, don't send any notifications\n-    \n-    # Construct the message based on the action\n-    if action == 'created':\n-        verb = \"created\"\n-        description = f\"A new {instance.__class__.__name__} was created.\"\n-    elif action == 'updated':\n-        verb = \"updated\"\n-        description = f\"The {instance.__class__.__name__} was updated.\"\n-    elif action == 'deleted':\n-        verb = \"deleted\"\n-        description = f\"The {instance.__class__.__name__} was deleted.\"\n-\n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Check if the actor (user) is a superadmin\n-    if instance.user and instance.user.is_superuser:\n-        # If the actor is a superadmin, send notifications to all users\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            notify.send(\n-                instance.user,  # Actor (superadmin who triggered the action)\n-                recipient=user,  # All users will be notified\n-                verb=verb,\n-                description=description\n-            )\n-    else:\n-        # Send notification to the specific recipient\n-        notify.send(\n-            instance.user,  # Actor (the user who triggered the action)\n-            recipient=recipient,\n-            verb=verb,\n-            description=description\n-        )\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Get all models in the project\n-        if hasattr(model, 'user'):  # Filter models with 'user' field (you can modify this)\n-            # Handle post_save (creation and updates)\n-            post_save.connect(handle_save, sender=model)\n-\n-            # Handle post_delete (deletion)\n-            post_delete.connect(handle_delete, sender=model)\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n"
                },
                {
                    "date": 1739686317667,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n from notifications.signals import notify\n-from django.contrib.auth.models import User\n+# from django.contrib.auth.models import User\n from django.apps import apps\n \n # ðŸ“Œ Generic function to send notifications\n def send_notification(instance, action, recipient=None, additional_info=None):\n"
                },
                {
                    "date": 1739686324152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n from notifications.signals import notify\n # from django.contrib.auth.models import User\n+from\n from django.apps import apps\n \n # ðŸ“Œ Generic function to send notifications\n def send_notification(instance, action, recipient=None, additional_info=None):\n"
                },
                {
                    "date": 1739689224752,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,44 +1,58 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n from notifications.signals import notify\n-# from django.contrib.auth.models import User\n-from\n from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n \n-# ðŸ“Œ Generic function to send notifications\n+User = get_user_model()\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",  \n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Function to send notifications based on permissions and actions\n def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    # For example, assume that each model has a `user` field indicating the owner or relevant user\n-    if hasattr(instance, 'user'):  # Check if the model has a `user` field (modify this as needed)\n-        recipient = instance.user  # The user associated with this instance (model)\n+    \"\"\" Sends notifications for all CRUD actions, checking user permissions. \"\"\"\n     \n-    # If there's no `user` attribute, you can customize how you determine the recipient\n-    else:\n-        # Example: if there's a creator or owner field, you can notify that user instead\n-        pass\n+    if not recipient and hasattr(instance, 'user'):\n+        recipient = instance.user  # Default recipient from the instance's user field\n     \n+    # If no recipient found, skip notification\n     if not recipient:\n-        return  # If there's no recipient defined, don't send any notifications\n+        return\n+\n+    # Fetch permissions for the recipient user\n+    group_permissions = get_group_permissions(recipient)\n+    model_name = instance.__class__.__name__.lower()  # Dynamically get model name from instance class name\n+\n+    # Log the model name for debugging\n+    logger.debug(f\"Model Name: {model_name}, Action: {action}\")\n+\n+    action_permission = ACTION_PERMISSION_MAPPING.get(action)\n+\n+    # Check if user has permission for the specific action\n+    if action_permission and action_permission not in group_permissions.get(model_name, set()):\n+        return  # User lacks permission to perform this action\n     \n-    # Construct the message based on the action\n-    if action == 'created':\n-        verb = \"created\"\n-        description = f\"A new {instance.__class__.__name__} was created.\"\n-    elif action == 'updated':\n-        verb = \"updated\"\n-        description = f\"The {instance.__class__.__name__} was updated.\"\n-    elif action == 'deleted':\n-        verb = \"deleted\"\n-        description = f\"The {instance.__class__.__name__} was deleted.\"\n-\n-    # Add additional info to description if available\n+    # Construct notification message based on action\n+    verb = action\n+    description = f\"The {instance.__class__.__name__} was {action}.\"\n     if additional_info:\n         description += f\" Additional Info: {additional_info}\"\n \n-    # Check if the actor (user) is a superadmin\n+    # Check if the actor is a superuser (send to all users)\n     if instance.user and instance.user.is_superuser:\n-        # If the actor is a superadmin, send notifications to all users\n         all_users = User.objects.all()\n         for user in all_users:\n             notify.send(\n                 instance.user,  # Actor (superadmin who triggered the action)\n@@ -49,32 +63,36 @@\n     else:\n         # Send notification to the specific recipient\n         notify.send(\n             instance.user,  # Actor (the user who triggered the action)\n-            recipient=recipient,\n+            recipient=recipient, \n             verb=verb,\n             description=description\n         )\n \n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Get all models in the project\n-        if hasattr(model, 'user'):  # Filter models with 'user' field (you can modify this)\n-            # Handle post_save (creation and updates)\n-            post_save.connect(handle_save, sender=model)\n-\n-            # Handle post_delete (deletion)\n-            post_delete.connect(handle_delete, sender=model)\n-\n # ðŸ“Œ Handle post_save signals (for creation or updates)\n @receiver(post_save)\n def handle_save(sender, instance, created, **kwargs):\n     action = 'created' if created else 'updated'\n+    \n+    # Log the model name and action for debugging purposes\n+    logger.debug(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+\n     send_notification(instance, action, recipient=None)\n \n # ðŸ“Œ Handle post_delete signals (for deletions)\n @receiver(post_delete)\n def handle_delete(sender, instance, **kwargs):\n+    # Log the model name and deletion for debugging purposes\n+    logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n     send_notification(instance, action='deleted', recipient=None)\n \n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+\n # ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n connect_signals()\n"
                },
                {
                    "date": 1739689237943,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,9 +74,9 @@\n def handle_save(sender, instance, created, **kwargs):\n     action = 'created' if created else 'updated'\n     \n     # Log the model name and action for debugging purposes\n-    logger.debug(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n \n     send_notification(instance, action, recipient=None)\n \n # ðŸ“Œ Handle post_delete signals (for deletions)\n"
                },
                {
                    "date": 1739689284481,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,99 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from \n+\n+User = get_user_model()\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",  \n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Function to send notifications based on permissions and actions\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions, checking user permissions. \"\"\"\n+    \n+    if not recipient and hasattr(instance, 'user'):\n+        recipient = instance.user  # Default recipient from the instance's user field\n+    \n+    # If no recipient found, skip notification\n+    if not recipient:\n+        return\n+\n+    # Fetch permissions for the recipient user\n+    group_permissions = get_group_permissions(recipient)\n+    model_name = instance.__class__.__name__.lower()  # Dynamically get model name from instance class name\n+\n+    # Log the model name for debugging\n+    logger.debug(f\"Model Name: {model_name}, Action: {action}\")\n+\n+    action_permission = ACTION_PERMISSION_MAPPING.get(action)\n+\n+    # Check if user has permission for the specific action\n+    if action_permission and action_permission not in group_permissions.get(model_name, set()):\n+        return  # User lacks permission to perform this action\n+    \n+    # Construct notification message based on action\n+    verb = action\n+    description = f\"The {instance.__class__.__name__} was {action}.\"\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Check if the actor is a superuser (send to all users)\n+    if instance.user and instance.user.is_superuser:\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            notify.send(\n+                instance.user,  # Actor (superadmin who triggered the action)\n+                recipient=user,  # All users will be notified\n+                verb=verb,\n+                description=description\n+            )\n+    else:\n+        # Send notification to the specific recipient\n+        notify.send(\n+            instance.user,  # Actor (the user who triggered the action)\n+            recipient=recipient, \n+            verb=verb,\n+            description=description\n+        )\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the model name and action for debugging purposes\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the model name and deletion for debugging purposes\n+    logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739689298833,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n from notifications.signals import notify\n from django.apps import apps\n from django.contrib.auth import get_user_model\n import logging\n-from \n+from mainproj.permissions import get_group_permissions\n \n User = get_user_model()\n \n # Action-to-Permission Mapping\n@@ -96,102 +96,4 @@\n             post_delete.connect(handle_delete, sender=model)\n \n # ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-\n-User = get_user_model()\n-\n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",  \n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n-\n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n-# Function to send notifications based on permissions and actions\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions, checking user permissions. \"\"\"\n-    \n-    if not recipient and hasattr(instance, 'user'):\n-        recipient = instance.user  # Default recipient from the instance's user field\n-    \n-    # If no recipient found, skip notification\n-    if not recipient:\n-        return\n-\n-    # Fetch permissions for the recipient user\n-    group_permissions = get_group_permissions(recipient)\n-    model_name = instance.__class__.__name__.lower()  # Dynamically get model name from instance class name\n-\n-    # Log the model name for debugging\n-    logger.debug(f\"Model Name: {model_name}, Action: {action}\")\n-\n-    action_permission = ACTION_PERMISSION_MAPPING.get(action)\n-\n-    # Check if user has permission for the specific action\n-    if action_permission and action_permission not in group_permissions.get(model_name, set()):\n-        return  # User lacks permission to perform this action\n-    \n-    # Construct notification message based on action\n-    verb = action\n-    description = f\"The {instance.__class__.__name__} was {action}.\"\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Check if the actor is a superuser (send to all users)\n-    if instance.user and instance.user.is_superuser:\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            notify.send(\n-                instance.user,  # Actor (superadmin who triggered the action)\n-                recipient=user,  # All users will be notified\n-                verb=verb,\n-                description=description\n-            )\n-    else:\n-        # Send notification to the specific recipient\n-        notify.send(\n-            instance.user,  # Actor (the user who triggered the action)\n-            recipient=recipient, \n-            verb=verb,\n-            description=description\n-        )\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    \n-    # Log the model name and action for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-\n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the model name and deletion for debugging purposes\n-    logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n"
                },
                {
                    "date": 1739689855104,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,99 +1,72 @@\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-from mainproj.permissions import get_group_permissions\n+# Fetch group permissions as per your DynamicModelPermission class\n+def get_group_permissions(user):\n+    \"\"\"\n+    Fetch all permissions from user groups.\n+    Returns a dictionary mapping models to their allowed actions.\n+    \"\"\"\n+    group_permissions = {}\n \n-User = get_user_model()\n+    # Loop through all user groups and collect permissions\n+    for group in user.groups.all():\n+        for perm in group.permissions.all():\n+            # Extract model name and action type from permission codename\n+            try:\n+                action, model_name = perm.codename.split(\"_\", 1)  # Example: \"add_socialmedia\"\n+                if model_name not in group_permissions:\n+                    group_permissions[model_name] = set()\n+                group_permissions[model_name].add(action)\n+            except ValueError:\n+                continue  # Skip invalid permissions\n \n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",  \n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n+    return group_permissions\n \n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n-# Function to send notifications based on permissions and actions\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions, checking user permissions. \"\"\"\n+def send_notification(instance, action, additional_info=None):\n+    \"\"\" Sends notifications to all users for CRUD actions if they have the required permissions \"\"\"\n     \n-    if not recipient and hasattr(instance, 'user'):\n-        recipient = instance.user  # Default recipient from the instance's user field\n+    # Use instance._meta.model_name to get the model's name dynamically\n+    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n     \n-    # If no recipient found, skip notification\n-    if not recipient:\n-        return\n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n \n-    # Fetch permissions for the recipient user\n-    group_permissions = get_group_permissions(recipient)\n-    model_name = instance.__class__.__name__.lower()  # Dynamically get model name from instance class name\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n \n-    # Log the model name for debugging\n-    logger.debug(f\"Model Name: {model_name}, Action: {action}\")\n+    # Fetch all users (you can customize the filtering if needed)\n+    all_users = User.objects.all()\n \n-    action_permission = ACTION_PERMISSION_MAPPING.get(action)\n+    # Get the group permissions for the user triggering the action\n+    for user in all_users:\n+        # Skip users who do not have permission for the model\n+        group_permissions = get_group_permissions(user)\n \n-    # Check if user has permission for the specific action\n-    if action_permission and action_permission not in group_permissions.get(model_name, set()):\n-        return  # User lacks permission to perform this action\n-    \n-    # Construct notification message based on action\n-    verb = action\n-    description = f\"The {instance.__class__.__name__} was {action}.\"\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n+        # Check if the user has permission for this model and action\n+        if model_name not in group_permissions or action not in group_permissions[model_name]:\n+            continue  # Skip sending notification to this user\n \n-    # Check if the actor is a superuser (send to all users)\n-    if instance.user and instance.user.is_superuser:\n-        all_users = User.objects.all()\n-        for user in all_users:\n+        # Send notification to users who have the required permission\n+        if instance.user and instance.user.is_superuser:\n+            # If the actor is superuser, send notification to all users who have the permission\n             notify.send(\n                 instance.user,  # Actor (superadmin who triggered the action)\n-                recipient=user,  # All users will be notified\n+                recipient=user,  # User with permission\n                 verb=verb,\n                 description=description\n             )\n-    else:\n-        # Send notification to the specific recipient\n-        notify.send(\n-            instance.user,  # Actor (the user who triggered the action)\n-            recipient=recipient, \n-            verb=verb,\n-            description=description\n-        )\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    \n-    # Log the model name and action for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-\n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the model name and deletion for debugging purposes\n-    logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n+        elif action != 'delete':  # Prevent sending delete notifications to restricted users\n+            # Send notification to the specific user if they have permission\n+            notify.send(\n+                instance.user,  # Actor (the user who triggered the action)\n+                recipient=user,  # User with permission\n+                verb=verb,\n+                description=description\n+            )\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739689870997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,12 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from mainproj.permissions import get_group_permissions\n+\n # Fetch group permissions as per your DynamicModelPermission class\n def get_group_permissions(user):\n     \"\"\"\n     Fetch all permissions from user groups.\n"
                },
                {
                    "date": 1739689878514,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,76 +5,95 @@\n from django.contrib.auth import get_user_model\n import logging\n from mainproj.permissions import get_group_permissions\n \n-# Fetch group permissions as per your DynamicModelPermission class\n-def get_group_permissions(user):\n-    \"\"\"\n-    Fetch all permissions from user groups.\n-    Returns a dictionary mapping models to their allowed actions.\n-    \"\"\"\n-    group_permissions = {}\n+User = get_user_model()\n \n-    # Loop through all user groups and collect permissions\n-    for group in user.groups.all():\n-        for perm in group.permissions.all():\n-            # Extract model name and action type from permission codename\n-            try:\n-                action, model_name = perm.codename.split(\"_\", 1)  # Example: \"add_socialmedia\"\n-                if model_name not in group_permissions:\n-                    group_permissions[model_name] = set()\n-                group_permissions[model_name].add(action)\n-            except ValueError:\n-                continue  # Skip invalid permissions\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",  \n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n \n-    return group_permissions\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n \n-def send_notification(instance, action, additional_info=None):\n-    \"\"\" Sends notifications to all users for CRUD actions if they have the required permissions \"\"\"\n+# Function to send notifications based on permissions and actions\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions, checking user permissions. \"\"\"\n     \n-    # Use instance._meta.model_name to get the model's name dynamically\n-    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n+    if not recipient and hasattr(instance, 'user'):\n+        recipient = instance.user  # Default recipient from the instance's user field\n     \n-    # Construct the message based on the action\n-    if action == 'created':\n-        verb = \"created\"\n-        description = f\"A new {model_name.capitalize()} was created.\"\n-    elif action == 'updated':\n-        verb = \"updated\"\n-        description = f\"The {model_name.capitalize()} was updated.\"\n-    elif action == 'deleted':\n-        verb = \"deleted\"\n-        description = f\"The {model_name.capitalize()} was deleted.\"\n+    # If no recipient found, skip notification\n+    if not recipient:\n+        return\n \n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n+    # Fetch permissions for the recipient user\n+    group_permissions = get_group_permissions(recipient)\n+    model_name = instance.__class__.__name__.lower()  # Dynamically get model name from instance class name\n \n-    # Fetch all users (you can customize the filtering if needed)\n-    all_users = User.objects.all()\n+    # Log the model name for debugging\n+    logger.debug(f\"Model Name: {model_name}, Action: {action}\")\n \n-    # Get the group permissions for the user triggering the action\n\\ No newline at end of file\n-    for user in all_users:\n-        # Skip users who do not have permission for the model\n-        group_permissions = get_group_permissions(user)\n+    action_permission = ACTION_PERMISSION_MAPPING.get(action)\n \n-        # Check if the user has permission for this model and action\n-        if model_name not in group_permissions or action not in group_permissions[model_name]:\n-            continue  # Skip sending notification to this user\n+    # Check if user has permission for the specific action\n+    if action_permission and action_permission not in group_permissions.get(model_name, set()):\n+        return  # User lacks permission to perform this action\n+    \n+    # Construct notification message based on action\n+    verb = action\n+    description = f\"The {instance.__class__.__name__} was {action}.\"\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n \n-        # Send notification to users who have the required permission\n-        if instance.user and instance.user.is_superuser:\n-            # If the actor is superuser, send notification to all users who have the permission\n+    # Check if the actor is a superuser (send to all users)\n+    if instance.user and instance.user.is_superuser:\n+        all_users = User.objects.all()\n+        for user in all_users:\n             notify.send(\n                 instance.user,  # Actor (superadmin who triggered the action)\n-                recipient=user,  # User with permission\n+                recipient=user,  # All users will be notified\n                 verb=verb,\n                 description=description\n             )\n-        elif action != 'delete':  # Prevent sending delete notifications to restricted users\n-            # Send notification to the specific user if they have permission\n-            notify.send(\n-                instance.user,  # Actor (the user who triggered the action)\n-                recipient=user,  # User with permission\n-                verb=verb,\n-                description=description\n-            )\n+    else:\n+        # Send notification to the specific recipient\n+        notify.send(\n+            instance.user,  # Actor (the user who triggered the action)\n+            recipient=recipient, \n+            verb=verb,\n+            description=description\n+        )\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the model name and action for debugging purposes\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the model name and deletion for debugging purposes\n+    logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739689891299,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,11 +4,10 @@\n from django.apps import apps\n from django.contrib.auth import get_user_model\n import logging\n from mainproj.permissions import get_group_permissions\n+from accounts.\n \n-User = get_user_model()\n-\n # Action-to-Permission Mapping\n ACTION_PERMISSION_MAPPING = {\n     \"list\": \"view\",  \n     \"retrieve\": \"view\",\n"
                },
                {
                    "date": 1739690086789,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n from django.apps import apps\n from django.contrib.auth import get_user_model\n import logging\n from mainproj.permissions import get_group_permissions\n-from accounts.\n+from accounts.models import CustomUser as User\n \n # Action-to-Permission Mapping\n ACTION_PERMISSION_MAPPING = {\n     \"list\": \"view\",  \n@@ -20,55 +20,63 @@\n # Logger setup for debugging\n logger = logging.getLogger(__name__)\n \n # Function to send notifications based on permissions and actions\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions, checking user permissions. \"\"\"\n+def send_notification(instance, action, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n     \n-    if not recipient and hasattr(instance, 'user'):\n-        recipient = instance.user  # Default recipient from the instance's user field\n-    \n-    # If no recipient found, skip notification\n-    if not recipient:\n+    # Special handling for admin LogEntry model\n+    if isinstance(instance, LogEntry):\n+        # Skip notifications for LogEntry (or handle separately)\n         return\n \n-    # Fetch permissions for the recipient user\n-    group_permissions = get_group_permissions(recipient)\n-    model_name = instance.__class__.__name__.lower()  # Dynamically get model name from instance class name\n+    # Use instance._meta.model_name to get the model's name dynamically\n+    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n+    \n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n \n-    # Log the model name for debugging\n-    logger.debug(f\"Model Name: {model_name}, Action: {action}\")\n-\n-    action_permission = ACTION_PERMISSION_MAPPING.get(action)\n-\n-    # Check if user has permission for the specific action\n-    if action_permission and action_permission not in group_permissions.get(model_name, set()):\n-        return  # User lacks permission to perform this action\n-    \n-    # Construct notification message based on action\n-    verb = action\n-    description = f\"The {instance.__class__.__name__} was {action}.\"\n+    # Add additional info to description if available\n     if additional_info:\n         description += f\" Additional Info: {additional_info}\"\n \n-    # Check if the actor is a superuser (send to all users)\n-    if instance.user and instance.user.is_superuser:\n-        all_users = User.objects.all()\n-        for user in all_users:\n+    # Fetch all users (you can customize the filtering if needed)\n+    all_users = User.objects.all()\n+\n+    # Get the group permissions for the user triggering the action\n+    for user in all_users:\n+        # Skip users who do not have permission for the model\n+        group_permissions = get_group_permissions(user)\n+\n+        # Check if the user has permission for this model and action\n+        if model_name not in group_permissions or action not in group_permissions[model_name]:\n+            continue  # Skip sending notification to this user\n+\n+        # Send notification to users who have the required permission\n+        if instance.user and instance.user.is_superuser:\n+            # If the actor is superuser, send notification to all users who have the permission\n             notify.send(\n                 instance.user,  # Actor (superadmin who triggered the action)\n-                recipient=user,  # All users will be notified\n+                recipient=user,  # User with permission\n                 verb=verb,\n                 description=description\n             )\n-    else:\n-        # Send notification to the specific recipient\n-        notify.send(\n-            instance.user,  # Actor (the user who triggered the action)\n-            recipient=recipient, \n-            verb=verb,\n-            description=description\n-        )\n+        elif action != 'delete':  # Prevent sending delete notifications to restricted users\n+            # Send notification to the specific user if they have permission\n+            notify.send(\n+                instance.user,  # Actor (the user who triggered the action)\n+                recipient=user,  # User with permission\n+                verb=verb,\n+                description=description\n+            )\n \n # ðŸ“Œ Handle post_save signals (for creation or updates)\n @receiver(post_save)\n def handle_save(sender, instance, created, **kwargs):\n"
                },
                {
                    "date": 1739690102701,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,9 @@\n from django.contrib.auth import get_user_model\n import logging\n from mainproj.permissions import get_group_permissions\n from accounts.models import CustomUser as User\n+from django.contrib.admin.models import LogEntry\n \n # Action-to-Permission Mapping\n ACTION_PERMISSION_MAPPING = {\n     \"list\": \"view\",  \n"
                },
                {
                    "date": 1739690110156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,107 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from mainproj.permissions import get_group_permissions\n+from accounts.models import CustomUser as User\n+from django.contrib.admin.models import LogEntry\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",  \n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Function to send notifications based on permissions and actions\n+def send_notification(instance, action, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    \n+    # Special handling for admin LogEntry model\n+    if isinstance(instance, LogEntry):\n+        # Skip notifications for LogEntry (or handle separately)\n+        return\n+\n+    # Use instance._meta.model_name to get the model's name dynamically\n+    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n+    \n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n+\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Fetch all users (you can customize the filtering if needed)\n+    all_users = User.objects.all()\n+\n+    # Get the group permissions for the user triggering the action\n+    for user in all_users:\n+        # Skip users who do not have permission for the model\n+        group_permissions = get_group_permissions(user)\n+\n+        # Check if the user has permission for this model and action\n+        if model_name not in group_permissions or action not in group_permissions[model_name]:\n+            continue  # Skip sending notification to this user\n+\n+        # Send notification to users who have the required permission\n+        if instance.user and instance.user.is_superuser:\n+            # If the actor is superuser, send notification to all users who have the permission\n+            notify.send(\n+                instance.user,  # Actor (superadmin who triggered the action)\n+                recipient=user,  # User with permission\n+                verb=verb,\n+                description=description\n+            )\n+        elif action != 'delete':  # Prevent sending delete notifications to restricted users\n+            # Send notification to the specific user if they have permission\n+            notify.send(\n+                instance.user,  # Actor (the user who triggered the action)\n+                recipient=user,  # User with permission\n+                verb=verb,\n+                description=description\n+            )\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the model name and action for debugging purposes\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the model name and deletion for debugging purposes\n+    logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739690200659,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n # Logger setup for debugging\n logger = logging.getLogger(__name__)\n \n # Function to send notifications based on permissions and actions\n-def send_notification(instance, action, additional_info=None):\n+def send_notification(instance, action, recipient=None, additional_info=None):\n     \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n     \n     # Special handling for admin LogEntry model\n     if isinstance(instance, LogEntry):\n@@ -47,37 +47,27 @@\n     # Add additional info to description if available\n     if additional_info:\n         description += f\" Additional Info: {additional_info}\"\n \n-    # Fetch all users (you can customize the filtering if needed)\n-    all_users = User.objects.all()\n-\n-    # Get the group permissions for the user triggering the action\n-    for user in all_users:\n-        # Skip users who do not have permission for the model\n-        group_permissions = get_group_permissions(user)\n-\n-        # Check if the user has permission for this model and action\n-        if model_name not in group_permissions or action not in group_permissions[model_name]:\n-            continue  # Skip sending notification to this user\n-\n-        # Send notification to users who have the required permission\n-        if instance.user and instance.user.is_superuser:\n-            # If the actor is superuser, send notification to all users who have the permission\n+    # Check if recipient is provided, otherwise notify all users\n+    if not recipient:\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            # Send notification to all users who have permission\n             notify.send(\n                 instance.user,  # Actor (superadmin who triggered the action)\n                 recipient=user,  # User with permission\n                 verb=verb,\n                 description=description\n             )\n-        elif action != 'delete':  # Prevent sending delete notifications to restricted users\n-            # Send notification to the specific user if they have permission\n-            notify.send(\n-                instance.user,  # Actor (the user who triggered the action)\n-                recipient=user,  # User with permission\n-                verb=verb,\n-                description=description\n-            )\n+    else:\n+        # Send notification to the specific recipient if provided\n+        notify.send(\n+            instance.user,  # Actor (the user who triggered the action)\n+            recipient=recipient,\n+            verb=verb,\n+            description=description\n+        )\n \n # ðŸ“Œ Handle post_save signals (for creation or updates)\n @receiver(post_save)\n def handle_save(sender, instance, created, **kwargs):\n@@ -104,111 +94,4 @@\n             post_delete.connect(handle_delete, sender=model)\n \n # ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-from mainproj.permissions import get_group_permissions\n-from accounts.models import CustomUser as User\n-from django.contrib.admin.models import LogEntry\n-\n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",  \n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n-\n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n-# Function to send notifications based on permissions and actions\n-def send_notification(instance, action, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    \n-    # Special handling for admin LogEntry model\n-    if isinstance(instance, LogEntry):\n-        # Skip notifications for LogEntry (or handle separately)\n-        return\n-\n-    # Use instance._meta.model_name to get the model's name dynamically\n-    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n-    \n-    # Construct the message based on the action\n-    if action == 'created':\n-        verb = \"created\"\n-        description = f\"A new {model_name.capitalize()} was created.\"\n-    elif action == 'updated':\n-        verb = \"updated\"\n-        description = f\"The {model_name.capitalize()} was updated.\"\n-    elif action == 'deleted':\n-        verb = \"deleted\"\n-        description = f\"The {model_name.capitalize()} was deleted.\"\n-\n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Fetch all users (you can customize the filtering if needed)\n-    all_users = User.objects.all()\n-\n-    # Get the group permissions for the user triggering the action\n-    for user in all_users:\n-        # Skip users who do not have permission for the model\n-        group_permissions = get_group_permissions(user)\n-\n-        # Check if the user has permission for this model and action\n-        if model_name not in group_permissions or action not in group_permissions[model_name]:\n-            continue  # Skip sending notification to this user\n-\n-        # Send notification to users who have the required permission\n-        if instance.user and instance.user.is_superuser:\n-            # If the actor is superuser, send notification to all users who have the permission\n-            notify.send(\n-                instance.user,  # Actor (superadmin who triggered the action)\n-                recipient=user,  # User with permission\n-                verb=verb,\n-                description=description\n-            )\n-        elif action != 'delete':  # Prevent sending delete notifications to restricted users\n-            # Send notification to the specific user if they have permission\n-            notify.send(\n-                instance.user,  # Actor (the user who triggered the action)\n-                recipient=user,  # User with permission\n-                verb=verb,\n-                description=description\n-            )\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    \n-    # Log the model name and action for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-\n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the model name and deletion for debugging purposes\n-    logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n"
                },
                {
                    "date": 1739690274978,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,8 +28,12 @@\n     # Special handling for admin LogEntry model\n     if isinstance(instance, LogEntry):\n         # Skip notifications for LogEntry (or handle separately)\n         return\n+    \n+    # Special handling for Notification model (to avoid accessing 'user' on Notification)\n+    if isinstance(instance, Notification):\n+        return  # Skip notification creation for already created notifications\n \n     # Use instance._meta.model_name to get the model's name dynamically\n     model_name = instance._meta.model_name  # This will return the lowercased name of the model\n     \n@@ -47,28 +51,26 @@\n     # Add additional info to description if available\n     if additional_info:\n         description += f\" Additional Info: {additional_info}\"\n \n+    # Ensure that the instance has a 'user' attribute, otherwise skip\n+    if hasattr(instance, 'user'):\n+        # If 'user' attribute exists, use it to send notifications\n+        actor = instance.user\n+    else:\n+        # Handle scenarios where 'user' is not present, use a default or skip\n+        actor = None\n+\n     # Check if recipient is provided, otherwise notify all users\n-    if not recipient:\n-        all_users = User.objects.all()\n+    if recipient is None:\n+        all_users = User.objects.all()  # Send to all users if no specific recipient\n         for user in all_users:\n-            # Send notification to all users who have permission\n-            notify.send(\n-                instance.user,  # Actor (superadmin who triggered the action)\n-                recipient=user,  # User with permission\n-                verb=verb,\n-                description=description\n-            )\n+            if actor:  # Only send if we have an actor (user)\n+                notify.send(actor, recipient=user, verb=verb, description=description)\n     else:\n         # Send notification to the specific recipient if provided\n-        notify.send(\n-            instance.user,  # Actor (the user who triggered the action)\n-            recipient=recipient,\n-            verb=verb,\n-            description=description\n-        )\n-\n+        if actor:\n+            notify.send(actor, recipient=recipient, verb=verb, description=description)\n # ðŸ“Œ Handle post_save signals (for creation or updates)\n @receiver(post_save)\n def handle_save(sender, instance, created, **kwargs):\n     action = 'created' if created else 'updated'\n"
                },
                {
                    "date": 1739690293512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,11 @@\n import logging\n from mainproj.permissions import get_group_permissions\n from accounts.models import CustomUser as User\n from django.contrib.admin.models import LogEntry\n+from notifications.models import Notification  # Import Notification model\n \n+\n # Action-to-Permission Mapping\n ACTION_PERMISSION_MAPPING = {\n     \"list\": \"view\",  \n     \"retrieve\": \"view\",\n@@ -69,8 +71,9 @@\n     else:\n         # Send notification to the specific recipient if provided\n         if actor:\n             notify.send(actor, recipient=recipient, verb=verb, description=description)\n+            \n # ðŸ“Œ Handle post_save signals (for creation or updates)\n @receiver(post_save)\n def handle_save(sender, instance, created, **kwargs):\n     action = 'created' if created else 'updated'\n"
                },
                {
                    "date": 1739690539091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n import logging\n from mainproj.permissions import get_group_permissions\n from accounts.models import CustomUser as User\n from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification  # Import Notification model\n+from notifications.models import Notification  \n \n \n # Action-to-Permission Mapping\n ACTION_PERMISSION_MAPPING = {\n"
                },
                {
                    "date": 1739690547705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,14 +6,13 @@\n import logging\n from mainproj.permissions import get_group_permissions\n from accounts.models import CustomUser as User\n from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification  \n+from notifications.models import Notification\n \n-\n # Action-to-Permission Mapping\n ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",  \n+    \"list\": \"view\",\n     \"retrieve\": \"view\",\n     \"create\": \"add\",\n     \"update\": \"change\",\n     \"partial_update\": \"change\",\n@@ -26,73 +25,69 @@\n # Function to send notifications based on permissions and actions\n def send_notification(instance, action, recipient=None, additional_info=None):\n     \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n     \n-    # Special handling for admin LogEntry model\n+    # Skip notifications for LogEntry model\n     if isinstance(instance, LogEntry):\n-        # Skip notifications for LogEntry (or handle separately)\n         return\n     \n-    # Special handling for Notification model (to avoid accessing 'user' on Notification)\n+    # Skip notifications for Notification model itself to avoid recursion\n     if isinstance(instance, Notification):\n-        return  # Skip notification creation for already created notifications\n+        return\n \n-    # Use instance._meta.model_name to get the model's name dynamically\n-    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n+    # Get model name dynamically\n+    model_name = instance._meta.model_name\n     \n-    # Construct the message based on the action\n+    # Construct the notification message based on the action\n     if action == 'created':\n-        verb = \"created\"\n+        verb = f\"created\"\n         description = f\"A new {model_name.capitalize()} was created.\"\n     elif action == 'updated':\n-        verb = \"updated\"\n+        verb = f\"updated\"\n         description = f\"The {model_name.capitalize()} was updated.\"\n     elif action == 'deleted':\n-        verb = \"deleted\"\n+        verb = f\"deleted\"\n         description = f\"The {model_name.capitalize()} was deleted.\"\n \n     # Add additional info to description if available\n     if additional_info:\n         description += f\" Additional Info: {additional_info}\"\n \n-    # Ensure that the instance has a 'user' attribute, otherwise skip\n-    if hasattr(instance, 'user'):\n-        # If 'user' attribute exists, use it to send notifications\n-        actor = instance.user\n-    else:\n-        # Handle scenarios where 'user' is not present, use a default or skip\n-        actor = None\n+    # Check if the instance has a 'user' attribute for the actor\n+    actor = getattr(instance, 'user', None)\n \n-    # Check if recipient is provided, otherwise notify all users\n+    # If no recipient is provided, notify all users\n     if recipient is None:\n-        all_users = User.objects.all()  # Send to all users if no specific recipient\n+        all_users = User.objects.all()\n         for user in all_users:\n-            if actor:  # Only send if we have an actor (user)\n+            if actor:\n                 notify.send(actor, recipient=user, verb=verb, description=description)\n     else:\n-        # Send notification to the specific recipient if provided\n+        # Send notification to a specific recipient if provided\n         if actor:\n             notify.send(actor, recipient=recipient, verb=verb, description=description)\n-            \n+\n # ðŸ“Œ Handle post_save signals (for creation or updates)\n @receiver(post_save)\n def handle_save(sender, instance, created, **kwargs):\n     action = 'created' if created else 'updated'\n     \n-    # Log the model name and action for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-\n+    # Log the action and instance details for debugging purposes\n+    logger.debug(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+    \n+    # Send notification for the save action\n     send_notification(instance, action, recipient=None)\n \n # ðŸ“Œ Handle post_delete signals (for deletions)\n @receiver(post_delete)\n def handle_delete(sender, instance, **kwargs):\n-    # Log the model name and deletion for debugging purposes\n+    # Log the deletion for debugging purposes\n     logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n     \n+    # Send notification for the delete action\n     send_notification(instance, action='deleted', recipient=None)\n \n-# ðŸ“Œ Dynamically connect signals for all models\n+# ðŸ“Œ Dynamically connect signals for all models with a 'user' field\n def connect_signals():\n     for model in apps.get_models():  # Fetch all models dynamically\n         if hasattr(model, 'user'):  # Filter models that have a `user` field\n             post_save.connect(handle_save, sender=model)\n"
                },
                {
                    "date": 1739690647135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,9 +71,9 @@\n def handle_save(sender, instance, created, **kwargs):\n     action = 'created' if created else 'updated'\n     \n     # Log the action and instance details for debugging purposes\n-    logger.debug(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+    post(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n     \n     # Send notification for the save action\n     send_notification(instance, action, recipient=None)\n \n"
                },
                {
                    "date": 1739690663239,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,18 +71,18 @@\n def handle_save(sender, instance, created, **kwargs):\n     action = 'created' if created else 'updated'\n     \n     # Log the action and instance details for debugging purposes\n-    post(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n     \n     # Send notification for the save action\n     send_notification(instance, action, recipient=None)\n \n # ðŸ“Œ Handle post_delete signals (for deletions)\n @receiver(post_delete)\n def handle_delete(sender, instance, **kwargs):\n     # Log the deletion for debugging purposes\n-    logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n+    print(f\"Deleting {instance.__class__.__name__} instance\")\n     \n     # Send notification for the delete action\n     send_notification(instance, action='deleted', recipient=None)\n \n"
                },
                {
                    "date": 1739690679705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,98 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from mainproj.permissions import get_group_permissions\n+from accounts.models import CustomUser as User\n+from django.contrib.admin.models import LogEntry\n+from notifications.models import Notification\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",\n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Function to send notifications based on permissions and actions\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+    \n+    # Skip notifications for LogEntry model\n+    if isinstance(instance, LogEntry):\n+        return\n+    \n+    # Skip notifications for Notification model itself to avoid recursion\n+    if isinstance(instance, Notification):\n+        return\n+\n+    # Get model name dynamically\n+    model_name = instance._meta.model_name\n+    \n+    # Construct the notification message based on the action\n+    if action == 'created':\n+        verb = f\"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = f\"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = f\"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n+\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Check if the instance has a 'user' attribute for the actor\n+    actor = getattr(instance, 'user', None)\n+\n+    # If no recipient is provided, notify all users\n+    if recipient is None:\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            if actor:\n+                notify.send(actor, recipient=user, verb=verb, description=description)\n+    else:\n+        # Send notification to a specific recipient if provided\n+        if actor:\n+            notify.send(actor, recipient=recipient, verb=verb, description=description)\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the action and instance details for debugging purposes\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+    \n+    # Send notification for the save action\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the deletion for debugging purposes\n+    print(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    # Send notification for the delete action\n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Dynamically connect signals for all models with a 'user' field\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739690685575,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,98 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from mainproj.permissions import get_group_permissions\n+from accounts.models import CustomUser as User\n+from django.contrib.admin.models import LogEntry\n+from notifications.models import Notification\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",\n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Function to send notifications based on permissions and actions\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    print(f\"sending {instance.__class__.__name__} instance, Action: {action}\")\n+    \n+    # Skip notifications for LogEntry model\n+    if isinstance(instance, LogEntry):\n+        return\n+    \n+    # Skip notifications for Notification model itself to avoid recursion\n+    if isinstance(instance, Notification):\n+        return\n+\n+    # Get model name dynamically\n+    model_name = instance._meta.model_name\n+    \n+    # Construct the notification message based on the action\n+    if action == 'created':\n+        verb = f\"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = f\"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = f\"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n+\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Check if the instance has a 'user' attribute for the actor\n+    actor = getattr(instance, 'user', None)\n+\n+    # If no recipient is provided, notify all users\n+    if recipient is None:\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            if actor:\n+                notify.send(actor, recipient=user, verb=verb, description=description)\n+    else:\n+        # Send notification to a specific recipient if provided\n+        if actor:\n+            notify.send(actor, recipient=recipient, verb=verb, description=description)\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the action and instance details for debugging purposes\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+    \n+    # Send notification for the save action\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the deletion for debugging purposes\n+    print(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    # Send notification for the delete action\n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Dynamically connect signals for all models with a 'user' field\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739690853449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,284 +6,76 @@\n import logging\n from mainproj.permissions import get_group_permissions\n from accounts.models import CustomUser as User\n from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification\n+from notifications.models import Notification  \n \n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",\n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n-\n # Logger setup for debugging\n logger = logging.getLogger(__name__)\n \n-# Function to send notifications based on permissions and actions\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    print(f\"sending {instance.__class__.__name__} instance, Action: {action}\")\n-    \n-    # Skip notifications for LogEntry model\n-    if isinstance(instance, LogEntry):\n-        return\n-    \n-    # Skip notifications for Notification model itself to avoid recursion\n-    if isinstance(instance, Notification):\n-        return\n-\n-    # Get model name dynamically\n-    model_name = instance._meta.model_name\n-    \n-    # Construct the notification message based on the action\n-    if action == 'created':\n-        verb = f\"created\"\n-        description = f\"A new {model_name.capitalize()} was created.\"\n-    elif action == 'updated':\n-        verb = f\"updated\"\n-        description = f\"The {model_name.capitalize()} was updated.\"\n-    elif action == 'deleted':\n-        verb = f\"deleted\"\n-        description = f\"The {model_name.capitalize()} was deleted.\"\n-\n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Check if the instance has a 'user' attribute for the actor\n-    actor = getattr(instance, 'user', None)\n-\n-    # If no recipient is provided, notify all users\n-    if recipient is None:\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            if actor:\n-                notify.send(actor, recipient=user, verb=verb, description=description)\n-    else:\n-        # Send notification to a specific recipient if provided\n-        if actor:\n-            notify.send(actor, recipient=recipient, verb=verb, description=description)\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    \n-    # Log the action and instance details for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-    \n-    # Send notification for the save action\n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the deletion for debugging purposes\n-    print(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    # Send notification for the delete action\n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Dynamically connect signals for all models with a 'user' field\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-from mainproj.permissions import get_group_permissions\n-from accounts.models import CustomUser as User\n-from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification\n-\n # Action-to-Permission Mapping\n ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",\n+    \"list\": \"view\",  \n     \"retrieve\": \"view\",\n     \"create\": \"add\",\n     \"update\": \"change\",\n     \"partial_update\": \"change\",\n     \"destroy\": \"delete\",\n }\n \n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n # Function to send notifications based on permissions and actions\n def send_notification(instance, action, recipient=None, additional_info=None):\n     \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n     \n-    # Skip notifications for LogEntry model\n+    # Skip LogEntry and Notification model handling\n     if isinstance(instance, LogEntry):\n         return\n     \n-    # Skip notifications for Notification model itself to avoid recursion\n     if isinstance(instance, Notification):\n         return\n-\n-    # Get model name dynamically\n+    \n     model_name = instance._meta.model_name\n+    description = f\"The {model_name.capitalize()} was {action}.\"\n     \n-    # Construct the notification message based on the action\n-    if action == 'created':\n-        verb = f\"created\"\n-        description = f\"A new {model_name.capitalize()} was created.\"\n-    elif action == 'updated':\n-        verb = f\"updated\"\n-        description = f\"The {model_name.capitalize()} was updated.\"\n-    elif action == 'deleted':\n-        verb = f\"deleted\"\n-        description = f\"The {model_name.capitalize()} was deleted.\"\n-\n-    # Add additional info to description if available\n     if additional_info:\n         description += f\" Additional Info: {additional_info}\"\n \n-    # Check if the instance has a 'user' attribute for the actor\n-    actor = getattr(instance, 'user', None)\n+    if hasattr(instance, 'user'):\n+        actor = instance.user\n+    else:\n+        actor = None\n \n-    # If no recipient is provided, notify all users\n+    # Send notification to all users if recipient is None\n     if recipient is None:\n         all_users = User.objects.all()\n         for user in all_users:\n             if actor:\n-                notify.send(actor, recipient=user, verb=verb, description=description)\n+                # Using django-notifications-hq's notify.send function\n+                notify.send(actor, recipient=user, verb=action, description=description)\n     else:\n-        # Send notification to a specific recipient if provided\n         if actor:\n-            notify.send(actor, recipient=recipient, verb=verb, description=description)\n+            # Using django-notifications-hq's notify.send function\n+            notify.send(actor, recipient=recipient, verb=action, description=description)\n \n # ðŸ“Œ Handle post_save signals (for creation or updates)\n @receiver(post_save)\n def handle_save(sender, instance, created, **kwargs):\n     action = 'created' if created else 'updated'\n     \n-    # Log the action and instance details for debugging purposes\n+    # Log the model name and action for debugging purposes\n     print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-    \n-    # Send notification for the save action\n-    send_notification(instance, action, recipient=None)\n \n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the deletion for debugging purposes\n-    print(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    # Send notification for the delete action\n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Dynamically connect signals for all models with a 'user' field\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-from mainproj.permissions import get_group_permissions\n-from accounts.models import CustomUser as User\n-from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification\n-\n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",\n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n-\n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n-# Function to send notifications based on permissions and actions\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    \n-    # Skip notifications for LogEntry model\n-    if isinstance(instance, LogEntry):\n-        return\n-    \n-    # Skip notifications for Notification model itself to avoid recursion\n-    if isinstance(instance, Notification):\n-        return\n-\n-    # Get model name dynamically\n-    model_name = instance._meta.model_name\n-    \n-    # Construct the notification message based on the action\n-    if action == 'created':\n-        verb = f\"created\"\n-        description = f\"A new {model_name.capitalize()} was created.\"\n-    elif action == 'updated':\n-        verb = f\"updated\"\n-        description = f\"The {model_name.capitalize()} was updated.\"\n-    elif action == 'deleted':\n-        verb = f\"deleted\"\n-        description = f\"The {model_name.capitalize()} was deleted.\"\n-\n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Check if the instance has a 'user' attribute for the actor\n-    actor = getattr(instance, 'user', None)\n-\n-    # If no recipient is provided, notify all users\n-    if recipient is None:\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            if actor:\n-                notify.send(actor, recipient=user, verb=verb, description=description)\n-    else:\n-        # Send notification to a specific recipient if provided\n-        if actor:\n-            notify.send(actor, recipient=recipient, verb=verb, description=description)\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    \n-    # Log the action and instance details for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-    \n-    # Send notification for the save action\n     send_notification(instance, action, recipient=None)\n \n # ðŸ“Œ Handle post_delete signals (for deletions)\n @receiver(post_delete)\n def handle_delete(sender, instance, **kwargs):\n-    # Log the deletion for debugging purposes\n-    print(f\"Deleting {instance.__class__.__name__} instance\")\n+    # Log the model name and deletion for debugging purposes\n+    logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n     \n-    # Send notification for the delete action\n     send_notification(instance, action='deleted', recipient=None)\n \n-# ðŸ“Œ Dynamically connect signals for all models with a 'user' field\n+# ðŸ“Œ Dynamically connect signals for all models\n def connect_signals():\n     for model in apps.get_models():  # Fetch all models dynamically\n         if hasattr(model, 'user'):  # Filter models that have a `user` field\n             post_save.connect(handle_save, sender=model)\n"
                },
                {
                    "date": 1739690955847,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,85 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from mainproj.permissions import get_group_permissions\n+from accounts.models import CustomUser as User\n+from django.contrib.admin.models import LogEntry\n+from notifications.models import Notification  \n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",  \n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Function to send notifications based on permissions and actions\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    \n+    # Skip LogEntry and Notification model handling\n+    if isinstance(instance, LogEntry):\n+        return\n+    \n+    if isinstance(instance, Notification):\n+        return\n+    \n+    model_name = instance._meta.model_name\n+    description = f\"The {model_name.capitalize()} was {action}.\"\n+    \n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    if hasattr(instance, 'user'):\n+        actor = instance.user\n+    else:\n+        actor = None\n+\n+    # Send notification to all users if recipient is None\n+    if recipient is None:\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            if actor:\n+                # Using django-notifications-hq's notify.send function\n+                notify.send(actor, recipient=user, verb=action, description=description)\n+    else:\n+        if actor:\n+            # Using django-notifications-hq's notify.send function\n+            notify.send(actor, recipient=recipient, verb=action, description=description)\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the model name and action for debugging purposes\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the model name and deletion for debugging purposes\n+    print(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739691435007,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,123 +22,70 @@\n     \"destroy\": \"delete\",\n }\n \n # Function to send notifications based on permissions and actions\n+from notifications.models import Notification\n+from notifications.signals import notify\n+\n def send_notification(instance, action, recipient=None, additional_info=None):\n     \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n     \n-    # Skip LogEntry and Notification model handling\n+    # Skip notifications for LogEntry (admin activity logs)\n     if isinstance(instance, LogEntry):\n         return\n-    \n+\n+    # Skip notifications for already created notifications\n     if isinstance(instance, Notification):\n         return\n-    \n-    model_name = instance._meta.model_name\n-    description = f\"The {model_name.capitalize()} was {action}.\"\n-    \n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n \n-    if hasattr(instance, 'user'):\n-        actor = instance.user\n-    else:\n-        actor = None\n-\n-    # Send notification to all users if recipient is None\n-    if recipient is None:\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            if actor:\n-                # Using django-notifications-hq's notify.send function\n-                notify.send(actor, recipient=user, verb=action, description=description)\n-    else:\n-        if actor:\n-            # Using django-notifications-hq's notify.send function\n-            notify.send(actor, recipient=recipient, verb=action, description=description)\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n+    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n     \n-    # Log the model name and action for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n \n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the model name and deletion for debugging purposes\n-    print(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-from mainproj.permissions import get_group_permissions\n-from accounts.models import CustomUser as User\n-from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification  \n-\n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",  \n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n-\n-# Function to send notifications based on permissions and actions\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    \n-    # Skip LogEntry and Notification model handling\n-    if isinstance(instance, LogEntry):\n-        return\n-    \n-    if isinstance(instance, Notification):\n-        return\n-    \n-    model_name = instance._meta.model_name\n-    description = f\"The {model_name.capitalize()} was {action}.\"\n-    \n+    # Add additional info to description if available\n     if additional_info:\n         description += f\" Additional Info: {additional_info}\"\n \n+    # Ensure that the instance has a 'user' attribute, otherwise skip\n     if hasattr(instance, 'user'):\n         actor = instance.user\n     else:\n         actor = None\n \n-    # Send notification to all users if recipient is None\n+    # If no specific recipient is provided, send to all users\n     if recipient is None:\n         all_users = User.objects.all()\n         for user in all_users:\n             if actor:\n-                # Using django-notifications-hq's notify.send function\n-                notify.send(actor, recipient=user, verb=action, description=description)\n+                # Save the notification to the database explicitly\n+                notification = Notification(\n+                    recipient=user,\n+                    verb=verb,\n+                    description=description,\n+                    actor=actor\n+                )\n+                notification.save()\n     else:\n+        # Send notification to the specific recipient and save it to the database\n         if actor:\n+            notification = Notification(\n+                recipient=recipient,\n+                verb=verb,\n+                description=description,\n+                actor=actor\n+            )\n+            notification.save()\n+\n+        if actor:\n             # Using django-notifications-hq's notify.send function\n             notify.send(actor, recipient=recipient, verb=action, description=description)\n \n # ðŸ“Œ Handle post_save signals (for creation or updates)\n@@ -154,9 +101,9 @@\n # ðŸ“Œ Handle post_delete signals (for deletions)\n @receiver(post_delete)\n def handle_delete(sender, instance, **kwargs):\n     # Log the model name and deletion for debugging purposes\n-    logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n+    print(f\"Deleting {instance.__class__.__name__} instance\")\n     \n     send_notification(instance, action='deleted', recipient=None)\n \n # ðŸ“Œ Dynamically connect signals for all models\n"
                },
                {
                    "date": 1739691492346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,8 +72,9 @@\n                     description=description,\n                     actor=actor\n                 )\n                 notification.save()\n+                print(f\"Notification saved to {user} for action {action}\")\n     else:\n         # Send notification to the specific recipient and save it to the database\n         if actor:\n             notification = Notification(\n@@ -82,12 +83,10 @@\n                 description=description,\n                 actor=actor\n             )\n             notification.save()\n+            print(f\"Notification saved to {recipient} for action {action}\")\n \n-        if actor:\n-            # Using django-notifications-hq's notify.send function\n-            notify.send(actor, recipient=recipient, verb=action, description=description)\n \n # ðŸ“Œ Handle post_save signals (for creation or updates)\n @receiver(post_save)\n def handle_save(sender, instance, created, **kwargs):\n"
                },
                {
                    "date": 1739691756247,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,104 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from mainproj.permissions import get_group_permissions\n+from accounts.models import CustomUser as User\n+from django.contrib.admin.models import LogEntry\n+from notifications.models import Notification  \n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",  \n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Function to send notifications based on permissions and actions\n+from notifications.models import Notification\n+from notifications.signals import notify\n+\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    \n+    # Skip notifications for LogEntry (admin activity logs)\n+    if isinstance(instance, LogEntry):\n+        return\n+\n+    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n+\n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n+\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Ensure that the instance has a 'user' attribute, otherwise skip\n+    if hasattr(instance, 'user'):\n+        actor = instance.user\n+    else:\n+        actor = None\n+\n+    # If no specific recipient is provided, send to all users\n+    if recipient is None:\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            if actor:\n+                # Use django-notifications-hq's notify function\n+                notify.send(actor, recipient=user, verb=verb, description=description)\n+                print(f\"Notification sent to {user} for action {action}\")\n+            else:\n+                print(f\"Skipping notification for {user} - no actor\")\n+    else:\n+        # Send notification to the specific recipient\n+        if actor:\n+            notify.send(actor, recipient=recipient, verb=verb, description=description)\n+            print(f\"Notification sent to {recipient} for action {action}\")\n+        else:\n+            print(f\"Skipping notification for {recipient} - no actor\")\n+\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the model name and action for debugging purposes\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the model name and deletion for debugging purposes\n+    print(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739691765914,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,101 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from mainproj.permissions import get_group_permissions\n+from accounts.models import CustomUser as User\n+from django.contrib.admin.models import LogEntry\n+from notifications.models import Notification  \n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",  \n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Function to send notifications based on permissions and action\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    \n+    # Skip notifications for LogEntry (admin activity logs)\n+    if isinstance(instance, LogEntry):\n+        return\n+\n+    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n+\n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n+\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Ensure that the instance has a 'user' attribute, otherwise skip\n+    if hasattr(instance, 'user'):\n+        actor = instance.user\n+    else:\n+        actor = None\n+\n+    # If no specific recipient is provided, send to all users\n+    if recipient is None:\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            if actor:\n+                # Use django-notifications-hq's notify function\n+                notify.send(actor, recipient=user, verb=verb, description=description)\n+                print(f\"Notification sent to {user} for action {action}\")\n+            else:\n+                print(f\"Skipping notification for {user} - no actor\")\n+    else:\n+        # Send notification to the specific recipient\n+        if actor:\n+            notify.send(actor, recipient=recipient, verb=verb, description=description)\n+            print(f\"Notification sent to {recipient} for action {action}\")\n+        else:\n+            print(f\"Skipping notification for {recipient} - no actor\")\n+\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the model name and action for debugging purposes\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the model name and deletion for debugging purposes\n+    print(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739691861097,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,102 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from mainproj.permissions import get_group_permissions\n+from accounts.models import CustomUser as User\n+from django.contrib.admin.models import LogEntry\n+from notifications.models import Notification  \n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",  \n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Function to send notifications based on permissions and action\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    \n+    # Skip notifications for LogEntry (admin activity logs)\n+    if isinstance(instance, LogEntry):\n+        return\n+\n+    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n+\n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n+\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Ensure that the instance has a 'user' attribute, otherwise skip\n+    actor = getattr(instance, 'user', None)\n+\n+    # Logging the action details for debugging\n+    logger.debug(f\"Sending notification: actor={actor}, recipient={recipient}, verb={verb}, description={description}\")\n+\n+    # If no specific recipient is provided, send to all users\n+    if recipient is None:\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            if actor:\n+                # Use django-notifications-hq's notify function\n+                notify.send(actor, recipient=user, verb=verb, description=description)\n+                logger.debug(f\"Notification sent to {user} for action {action}\")\n+            else:\n+                logger.debug(f\"Skipping notification for {user} - no actor\")\n+    else:\n+        # Send notification to the specific recipient\n+        if actor:\n+            notify.send(actor, recipient=recipient, verb=verb, description=description)\n+            logger.debug(f\"Notification sent to {recipient} for action {action}\")\n+        else:\n+            logger.debug(f\"Skipping notification for {recipient} - no actor\")\n+\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the model name and action for debugging purposes\n+    logger.debug(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the model name and deletion for debugging purposes\n+    logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+            logger.debug(f\"Connected signals for model: {model.__name__}\")\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739691969864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,110 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from mainproj.permissions import get_group_permissions\n+from accounts.models import CustomUser as User\n+from django.contrib.admin.models import LogEntry\n+from notifications.models import Notification  \n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",  \n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Function to send notifications based on permissions and action\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    \n+    # Skip notifications for LogEntry (admin activity logs)\n+    if isinstance(instance, LogEntry):\n+        return\n+\n+    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n+\n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n+\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Ensure that the instance has a 'user' attribute, otherwise skip\n+    actor = getattr(instance, 'user', None)\n+\n+    # Debugging prints\n+    print(f\"Notification Details: actor={actor}, recipient={recipient}, verb={verb}, description={description}\")\n+\n+    # If no specific recipient is provided, send to all users\n+    if recipient is None:\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            if actor:\n+                # Use django-notifications-hq's notify function\n+                notify.send(actor, recipient=user, verb=verb, description=description)\n+                # Print to verify if the notification is being triggered\n+                print(f\"Notification sent to {user} for action {action}\")\n+                # Check if the notification is saved in the database\n+                latest_notification = Notification.objects.last()\n+                print(f\"Latest Notification: {latest_notification}\")\n+            else:\n+                print(f\"Skipping notification for {user} - no actor\")\n+    else:\n+        # Send notification to the specific recipient\n+        if actor:\n+            notify.send(actor, recipient=recipient, verb=verb, description=description)\n+            # Print to verify if the notification is being triggered\n+            print(f\"Notification sent to {recipient} for action {action}\")\n+            # Check if the notification is saved in the database\n+            latest_notification = Notification.objects.last()\n+            print(f\"Latest Notification: {latest_notification}\")\n+        else:\n+            print(f\"Skipping notification for {recipient} - no actor\")\n+\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the model name and action for debugging purposes\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the model name and deletion for debugging purposes\n+    print(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+            print(f\"Connected signals for model: {model.__name__}\")\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739691977602,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,427 +107,4 @@\n             print(f\"Connected signals for model: {model.__name__}\")\n \n # ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-from mainproj.permissions import get_group_permissions\n-from accounts.models import CustomUser as User\n-from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification  \n-\n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",  \n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n-\n-# Function to send notifications based on permissions and action\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    \n-    # Skip notifications for LogEntry (admin activity logs)\n-    if isinstance(instance, LogEntry):\n-        return\n-\n-    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n-\n-    # Construct the message based on the action\n-    if action == 'created':\n-        verb = \"created\"\n-        description = f\"A new {model_name.capitalize()} was created.\"\n-    elif action == 'updated':\n-        verb = \"updated\"\n-        description = f\"The {model_name.capitalize()} was updated.\"\n-    elif action == 'deleted':\n-        verb = \"deleted\"\n-        description = f\"The {model_name.capitalize()} was deleted.\"\n-\n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Ensure that the instance has a 'user' attribute, otherwise skip\n-    actor = getattr(instance, 'user', None)\n-\n-    # Logging the action details for debugging\n-    logger.debug(f\"Sending notification: actor={actor}, recipient={recipient}, verb={verb}, description={description}\")\n-\n-    # If no specific recipient is provided, send to all users\n-    if recipient is None:\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            if actor:\n-                # Use django-notifications-hq's notify function\n-                notify.send(actor, recipient=user, verb=verb, description=description)\n-                logger.debug(f\"Notification sent to {user} for action {action}\")\n-            else:\n-                logger.debug(f\"Skipping notification for {user} - no actor\")\n-    else:\n-        # Send notification to the specific recipient\n-        if actor:\n-            notify.send(actor, recipient=recipient, verb=verb, description=description)\n-            logger.debug(f\"Notification sent to {recipient} for action {action}\")\n-        else:\n-            logger.debug(f\"Skipping notification for {recipient} - no actor\")\n-\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    \n-    # Log the model name and action for debugging purposes\n-    logger.debug(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-\n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the model name and deletion for debugging purposes\n-    logger.debug(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-            logger.debug(f\"Connected signals for model: {model.__name__}\")\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-from mainproj.permissions import get_group_permissions\n-from accounts.models import CustomUser as User\n-from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification  \n-\n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",  \n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n-\n-# Function to send notifications based on permissions and action\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    \n-    # Skip notifications for LogEntry (admin activity logs)\n-    if isinstance(instance, LogEntry):\n-        return\n-\n-    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n-\n-    # Construct the message based on the action\n-    if action == 'created':\n-        verb = \"created\"\n-        description = f\"A new {model_name.capitalize()} was created.\"\n-    elif action == 'updated':\n-        verb = \"updated\"\n-        description = f\"The {model_name.capitalize()} was updated.\"\n-    elif action == 'deleted':\n-        verb = \"deleted\"\n-        description = f\"The {model_name.capitalize()} was deleted.\"\n-\n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Ensure that the instance has a 'user' attribute, otherwise skip\n-    if hasattr(instance, 'user'):\n-        actor = instance.user\n-    else:\n-        actor = None\n-\n-    # If no specific recipient is provided, send to all users\n-    if recipient is None:\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            if actor:\n-                # Use django-notifications-hq's notify function\n-                notify.send(actor, recipient=user, verb=verb, description=description)\n-                print(f\"Notification sent to {user} for action {action}\")\n-            else:\n-                print(f\"Skipping notification for {user} - no actor\")\n-    else:\n-        # Send notification to the specific recipient\n-        if actor:\n-            notify.send(actor, recipient=recipient, verb=verb, description=description)\n-            print(f\"Notification sent to {recipient} for action {action}\")\n-        else:\n-            print(f\"Skipping notification for {recipient} - no actor\")\n-\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    \n-    # Log the model name and action for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-\n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the model name and deletion for debugging purposes\n-    print(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-from mainproj.permissions import get_group_permissions\n-from accounts.models import CustomUser as User\n-from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification  \n-\n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",  \n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n-\n-# Function to send notifications based on permissions and actions\n-from notifications.models import Notification\n-from notifications.signals import notify\n-\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    \n-    # Skip notifications for LogEntry (admin activity logs)\n-    if isinstance(instance, LogEntry):\n-        return\n-\n-    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n-\n-    # Construct the message based on the action\n-    if action == 'created':\n-        verb = \"created\"\n-        description = f\"A new {model_name.capitalize()} was created.\"\n-    elif action == 'updated':\n-        verb = \"updated\"\n-        description = f\"The {model_name.capitalize()} was updated.\"\n-    elif action == 'deleted':\n-        verb = \"deleted\"\n-        description = f\"The {model_name.capitalize()} was deleted.\"\n-\n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Ensure that the instance has a 'user' attribute, otherwise skip\n-    if hasattr(instance, 'user'):\n-        actor = instance.user\n-    else:\n-        actor = None\n-\n-    # If no specific recipient is provided, send to all users\n-    if recipient is None:\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            if actor:\n-                # Use django-notifications-hq's notify function\n-                notify.send(actor, recipient=user, verb=verb, description=description)\n-                print(f\"Notification sent to {user} for action {action}\")\n-            else:\n-                print(f\"Skipping notification for {user} - no actor\")\n-    else:\n-        # Send notification to the specific recipient\n-        if actor:\n-            notify.send(actor, recipient=recipient, verb=verb, description=description)\n-            print(f\"Notification sent to {recipient} for action {action}\")\n-        else:\n-            print(f\"Skipping notification for {recipient} - no actor\")\n-\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    \n-    # Log the model name and action for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-\n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the model name and deletion for debugging purposes\n-    print(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-from mainproj.permissions import get_group_permissions\n-from accounts.models import CustomUser as User\n-from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification  \n-\n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",  \n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n-\n-# Function to send notifications based on permissions and actions\n-from notifications.models import Notification\n-from notifications.signals import notify\n-\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    \n-    # Skip notifications for LogEntry (admin activity logs)\n-    if isinstance(instance, LogEntry):\n-        return\n-\n-    # Skip notifications for already created notifications\n-    if isinstance(instance, Notification):\n-        return\n-\n-    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n-    \n-    # Construct the message based on the action\n-    if action == 'created':\n-        verb = \"created\"\n-        description = f\"A new {model_name.capitalize()} was created.\"\n-    elif action == 'updated':\n-        verb = \"updated\"\n-        description = f\"The {model_name.capitalize()} was updated.\"\n-    elif action == 'deleted':\n-        verb = \"deleted\"\n-        description = f\"The {model_name.capitalize()} was deleted.\"\n-\n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Ensure that the instance has a 'user' attribute, otherwise skip\n-    if hasattr(instance, 'user'):\n-        actor = instance.user\n-    else:\n-        actor = None\n-\n-    # If no specific recipient is provided, send to all users\n-    if recipient is None:\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            if actor:\n-                # Save the notification to the database explicitly\n-                notification = Notification(\n-                    recipient=user,\n-                    verb=verb,\n-                    description=description,\n-                    actor=actor\n-                )\n-                notification.save()\n-                print(f\"Notification saved to {user} for action {action}\")\n-    else:\n-        # Send notification to the specific recipient and save it to the database\n-        if actor:\n-            notification = Notification(\n-                recipient=recipient,\n-                verb=verb,\n-                description=description,\n-                actor=actor\n-            )\n-            notification.save()\n-            print(f\"Notification saved to {recipient} for action {action}\")\n-\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    \n-    # Log the model name and action for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-\n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the model name and deletion for debugging purposes\n-    print(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n"
                },
                {
                    "date": 1739696061608,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,53 +22,9 @@\n     \"destroy\": \"delete\",\n }\n \n # Function to send notifications based on permissions and action\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    \n-    # Skip notifications for LogEntry (admin activity logs)\n-    if isinstance(instance, LogEntry):\n-        return\n \n-    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n-\n-    # Construct the message based on the action\n-    if action == 'created':\n-        verb = \"created\"\n-        description = f\"A new {model_name.capitalize()} was created.\"\n-    elif action == 'updated':\n-        verb = \"updated\"\n-        description = f\"The {model_name.capitalize()} was updated.\"\n-    elif action == 'deleted':\n-        verb = \"deleted\"\n-        description = f\"The {model_name.capitalize()} was deleted.\"\n-\n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Ensure that the instance has a 'user' attribute, otherwise skip\n-    actor = getattr(instance, 'user', None)\n-\n-    # Debugging prints\n-    print(f\"Notification Details: actor={actor}, recipient={recipient}, verb={verb}, description={description}\")\n-\n-    # If no specific recipient is provided, send to all users\n-    if recipient is None:\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            if actor:\n-                # Use django-notifications-hq's notify function\n-                notify.send(actor, recipient=user, verb=verb, description=description)\n-                # Print to verify if the notification is being triggered\n-                print(f\"Notification sent to {user} for action {action}\")\n-                # Check if the notification is saved in the database\n-                latest_notification = Notification.objects.last()\n-                print(f\"Latest Notification: {latest_notification}\")\n-            else:\n-                print(f\"Skipping notification for {user} - no actor\")\n-    else:\n         # Send notification to the specific recipient\n         if actor:\n             notify.send(actor, recipient=recipient, verb=verb, description=description)\n             # Print to verify if the notification is being triggered\n"
                },
                {
                    "date": 1739696073722,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,110 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from mainproj.permissions import get_group_permissions\n+from accounts.models import CustomUser as User\n+from django.contrib.admin.models import LogEntry\n+from notifications.models import Notification  \n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",  \n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Function to send notifications based on permissions and action\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    \n+    # Skip notifications for LogEntry (admin activity logs)\n+    if isinstance(instance, LogEntry):\n+        return\n+\n+    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n+\n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n+\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Ensure that the instance has a 'user' attribute, otherwise skip\n+    actor = getattr(instance, 'user', None)\n+\n+    # Debugging prints\n+    print(f\"Notification Details: actor={actor}, recipient={recipient}, verb={verb}, description={description}\")\n+\n+    # If no specific recipient is provided, send to all users\n+    if recipient is None:\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            if actor:\n+                # Use django-notifications-hq's notify function\n+                notify.send(actor, recipient=user, verb=verb, description=description)\n+                # Print to verify if the notification is being triggered\n+                print(f\"Notification sent to {user} for action {action}\")\n+                # Check if the notification is saved in the database\n+                latest_notification = Notification.objects.last()\n+                print(f\"Latest Notification: {latest_notification}\")\n+            else:\n+                print(f\"Skipping notification for {user} - no actor\")\n+    else:\n+        # Send notification to the specific recipient\n+        if actor:\n+            notify.send(actor, recipient=recipient, verb=verb, description=description)\n+            # Print to verify if the notification is being triggered\n+            print(f\"Notification sent to {recipient} for action {action}\")\n+            # Check if the notification is saved in the database\n+            latest_notification = Notification.objects.last()\n+            print(f\"Latest Notification: {latest_notification}\")\n+        else:\n+            print(f\"Skipping notification for {recipient} - no actor\")\n+\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the model name and action for debugging purposes\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the model name and deletion for debugging purposes\n+    print(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+            print(f\"Connected signals for model: {model.__name__}\")\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739696082176,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,65 +22,11 @@\n     \"destroy\": \"delete\",\n }\n \n # Function to send notifications based on permissions and action\n-def send_notification(instance, action, recipient=None, additional_info=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    \n-    # Skip notifications for LogEntry (admin activity logs)\n-    if isinstance(instance, LogEntry):\n-        return\n \n-    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n \n-    # Construct the message based on the action\n-    if action == 'created':\n-        verb = \"created\"\n-        description = f\"A new {model_name.capitalize()} was created.\"\n-    elif action == 'updated':\n-        verb = \"updated\"\n-        description = f\"The {model_name.capitalize()} was updated.\"\n-    elif action == 'deleted':\n-        verb = \"deleted\"\n-        description = f\"The {model_name.capitalize()} was deleted.\"\n \n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Ensure that the instance has a 'user' attribute, otherwise skip\n-    actor = getattr(instance, 'user', None)\n-\n-    # Debugging prints\n-    print(f\"Notification Details: actor={actor}, recipient={recipient}, verb={verb}, description={description}\")\n-\n-    # If no specific recipient is provided, send to all users\n-    if recipient is None:\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            if actor:\n-                # Use django-notifications-hq's notify function\n-                notify.send(actor, recipient=user, verb=verb, description=description)\n-                # Print to verify if the notification is being triggered\n-                print(f\"Notification sent to {user} for action {action}\")\n-                # Check if the notification is saved in the database\n-                latest_notification = Notification.objects.last()\n-                print(f\"Latest Notification: {latest_notification}\")\n-            else:\n-                print(f\"Skipping notification for {user} - no actor\")\n-    else:\n-        # Send notification to the specific recipient\n-        if actor:\n-            notify.send(actor, recipient=recipient, verb=verb, description=description)\n-            # Print to verify if the notification is being triggered\n-            print(f\"Notification sent to {recipient} for action {action}\")\n-            # Check if the notification is saved in the database\n-            latest_notification = Notification.objects.last()\n-            print(f\"Latest Notification: {latest_notification}\")\n-        else:\n-            print(f\"Skipping notification for {recipient} - no actor\")\n-\n-\n # ðŸ“Œ Handle post_save signals (for creation or updates)\n @receiver(post_save)\n def handle_save(sender, instance, created, **kwargs):\n     action = 'created' if created else 'updated'\n@@ -107,70 +53,4 @@\n             print(f\"Connected signals for model: {model.__name__}\")\n \n # ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-from mainproj.permissions import get_group_permissions\n-from accounts.models import CustomUser as User\n-from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification  \n-\n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",  \n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n-\n-# Function to send notifications based on permissions and action\n-\n-        # Send notification to the specific recipient\n-        if actor:\n-            notify.send(actor, recipient=recipient, verb=verb, description=description)\n-            # Print to verify if the notification is being triggered\n-            print(f\"Notification sent to {recipient} for action {action}\")\n-            # Check if the notification is saved in the database\n-            latest_notification = Notification.objects.last()\n-            print(f\"Latest Notification: {latest_notification}\")\n-        else:\n-            print(f\"Skipping notification for {recipient} - no actor\")\n-\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    \n-    # Log the model name and action for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-\n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the model name and deletion for debugging purposes\n-    print(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-            print(f\"Connected signals for model: {model.__name__}\")\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n"
                },
                {
                    "date": 1739696091409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,107 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from mainproj.permissions import get_group_permissions\n+from accounts.models import CustomUser as User\n+from django.contrib.admin.models import LogEntry\n+from notifications.models import Notification  \n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",  \n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Function to send notifications based on permissions and action\n+def send_notification(instance, action, recipient=None, additional_info=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    \n+    # Skip notifications for LogEntry (admin activity logs)\n+    if isinstance(instance, LogEntry):\n+        return\n+\n+    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n+\n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n+\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Print instance details for debugging\n+    print(f\"Instance details: {instance}\")\n+\n+    # Ensure that the instance has a 'user' attribute, otherwise skip\n+    actor = getattr(instance, 'user', None)\n+    \n+    if not actor:\n+        print(f\"No actor found for instance {instance}. Skipping notification.\")\n+        return\n+\n+    # Logging the action details for debugging\n+    print(f\"Sending notification: actor={actor}, recipient={recipient}, verb={verb}, description={description}\")\n+\n+    # If no specific recipient is provided, send to all users\n+    if recipient is None:\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            # Save the notification data\n+            notify.send(actor, recipient=user, verb=verb, description=description)\n+            print(f\"Notification sent to {user} for action {action}\")\n+    else:\n+        # Save the notification data\n+        notify.send(actor, recipient=recipient, verb=verb, description=description)\n+        print(f\"Notification sent to {recipient} for action {action}\")\n+\n+    # Print model data after saving\n+    print(f\"Notification saved in model: {actor}, {recipient}, {verb}, {description}\")\n+\n+\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the model name and action for debugging purposes\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+\n+    send_notification(instance, action, recipient=None)\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the model name and deletion for debugging purposes\n+    print(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    send_notification(instance, action='deleted', recipient=None)\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+            print(f\"Connected signals for model: {model.__name__}\")\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n"
                },
                {
                    "date": 1739696411228,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,10 @@\n from mainproj.permissions import get_group_permissions\n from accounts.models import CustomUser as User\n from django.contrib.admin.models import LogEntry\n from notifications.models import Notification  \n+from django.contrib.contenttypes.models import ContentType\n+from django.utils.timezone import now\n \n # Logger setup for debugging\n logger = logging.getLogger(__name__)\n \n@@ -22,9 +24,9 @@\n     \"destroy\": \"delete\",\n }\n \n # Function to send notifications based on permissions and action\n-def send_notification(instance, action, recipient=None, additional_info=None):\n+def send_notification(instance, action, recipient=None, additional_info=None, request=None):\n     \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n     \n     # Skip notifications for LogEntry (admin activity logs)\n     if isinstance(instance, LogEntry):\n@@ -46,21 +48,35 @@\n     # Add additional info to description if available\n     if additional_info:\n         description += f\" Additional Info: {additional_info}\"\n \n-    # Print instance details for debugging\n-    print(f\"Instance details: {instance}\")\n-\n     # Ensure that the instance has a 'user' attribute, otherwise skip\n     actor = getattr(instance, 'user', None)\n     \n-    if not actor:\n-        print(f\"No actor found for instance {instance}. Skipping notification.\")\n-        return\n+    if actor:\n+        print(f\"Actor found for instance {instance}: {actor}\")\n+    else:\n+        print(f\"No actor found for instance {instance}. Using authenticated user for notification.\")\n \n+    # If request is provided, use the authenticated user as the actor\n+    if request and request.user.is_authenticated:\n+        actor = request.user\n+        print(f\"Authenticated user used as actor: {actor}\")\n+    \n     # Logging the action details for debugging\n     print(f\"Sending notification: actor={actor}, recipient={recipient}, verb={verb}, description={description}\")\n \n+    # Check for permissions if actor is available (ensure the actor has permissions)\n+    if actor and request:\n+        content_type = ContentType.objects.get_for_model(instance)\n+        has_permission = request.user.has_perm(f'{content_type.app_label}.view_{content_type.model}') or \\\n+                         request.user.has_perm(f'{content_type.app_label}.change_{content_type.model}') or \\\n+                         request.user.has_perm(f'{content_type.app_label}.delete_{content_type.model}')\n+\n+        if not has_permission:\n+            print(f\"User {actor.username} does not have permission to {action} {model_name}. Skipping notification.\")\n+            return\n+\n     # If no specific recipient is provided, send to all users\n     if recipient is None:\n         all_users = User.objects.all()\n         for user in all_users:\n@@ -74,27 +90,25 @@\n \n     # Print model data after saving\n     print(f\"Notification saved in model: {actor}, {recipient}, {verb}, {description}\")\n \n-\n-\n # ðŸ“Œ Handle post_save signals (for creation or updates)\n @receiver(post_save)\n def handle_save(sender, instance, created, **kwargs):\n     action = 'created' if created else 'updated'\n     \n     # Log the model name and action for debugging purposes\n     print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n \n-    send_notification(instance, action, recipient=None)\n+    send_notification(instance, action, recipient=None, request=kwargs.get('request'))\n \n # ðŸ“Œ Handle post_delete signals (for deletions)\n @receiver(post_delete)\n def handle_delete(sender, instance, **kwargs):\n     # Log the model name and deletion for debugging purposes\n     print(f\"Deleting {instance.__class__.__name__} instance\")\n     \n-    send_notification(instance, action='deleted', recipient=None)\n+    send_notification(instance, action='deleted', recipient=None, request=kwargs.get('request'))\n \n # ðŸ“Œ Dynamically connect signals for all models\n def connect_signals():\n     for model in apps.get_models():  # Fetch all models dynamically\n@@ -104,60 +118,5 @@\n             print(f\"Connected signals for model: {model.__name__}\")\n \n # ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n connect_signals()\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-from mainproj.permissions import get_group_permissions\n-from accounts.models import CustomUser as User\n-from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification  \n \n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",  \n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n-\n-# Function to send notifications based on permissions and action\n-\n-\n-\n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    \n-    # Log the model name and action for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n-\n-    send_notification(instance, action, recipient=None)\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the model name and deletion for debugging purposes\n-    print(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    send_notification(instance, action='deleted', recipient=None)\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-            print(f\"Connected signals for model: {model.__name__}\")\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n"
                },
                {
                    "date": 1739696484643,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,15 +24,21 @@\n     \"destroy\": \"delete\",\n }\n \n # Function to send notifications based on permissions and action\n+# Function to send notifications based on permissions and action\n def send_notification(instance, action, recipient=None, additional_info=None, request=None):\n     \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n     \n     # Skip notifications for LogEntry (admin activity logs)\n     if isinstance(instance, LogEntry):\n         return\n \n+    # Ensure that the instance is not None\n+    if instance is None:\n+        print(f\"Received None instance. Skipping notification.\")\n+        return\n+\n     model_name = instance._meta.model_name  # This will return the lowercased name of the model\n \n     # Construct the message based on the action\n     if action == 'created':\n@@ -90,8 +96,9 @@\n \n     # Print model data after saving\n     print(f\"Notification saved in model: {actor}, {recipient}, {verb}, {description}\")\n \n+\n # ðŸ“Œ Handle post_save signals (for creation or updates)\n @receiver(post_save)\n def handle_save(sender, instance, created, **kwargs):\n     action = 'created' if created else 'updated'\n"
                },
                {
                    "date": 1739696544154,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,135 @@\n+from django.db.models.signals import post_save, post_delete\n+from django.dispatch import receiver\n+from notifications.signals import notify\n+from django.apps import apps\n+from django.contrib.auth import get_user_model\n+import logging\n+from mainproj.permissions import get_group_permissions\n+from accounts.models import CustomUser as User\n+from django.contrib.admin.models import LogEntry\n+from notifications.models import Notification  \n+from django.contrib.contenttypes.models import ContentType\n+from django.utils.timezone import now\n+\n+# Logger setup for debugging\n+logger = logging.getLogger(__name__)\n+\n+# Action-to-Permission Mapping\n+ACTION_PERMISSION_MAPPING = {\n+    \"list\": \"view\",  \n+    \"retrieve\": \"view\",\n+    \"create\": \"add\",\n+    \"update\": \"change\",\n+    \"partial_update\": \"change\",\n+    \"destroy\": \"delete\",\n+}\n+\n+# Function to send notifications based on permissions and action\n+# Function to send notifications based on permissions and action\n+def send_notification(instance, action, recipient=None, additional_info=None, request=None):\n+    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n+    \n+    # Skip notifications for LogEntry (admin activity logs)\n+    if isinstance(instance, LogEntry):\n+        return\n+\n+    # Ensure that the instance is not None\n+    if instance is None:\n+        print(f\"Received None instance. Skipping notification.\")\n+        return\n+\n+    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n+\n+    # Construct the message based on the action\n+    if action == 'created':\n+        verb = \"created\"\n+        description = f\"A new {model_name.capitalize()} was created.\"\n+    elif action == 'updated':\n+        verb = \"updated\"\n+        description = f\"The {model_name.capitalize()} was updated.\"\n+    elif action == 'deleted':\n+        verb = \"deleted\"\n+        description = f\"The {model_name.capitalize()} was deleted.\"\n+\n+    # Add additional info to description if available\n+    if additional_info:\n+        description += f\" Additional Info: {additional_info}\"\n+\n+    # Ensure that the instance has a 'user' attribute, otherwise skip\n+    actor = getattr(instance, 'user', None)\n+    \n+    if actor:\n+        print(f\"Actor found for instance {instance}: {actor}\")\n+    else:\n+        print(f\"No actor found for instance {instance}. Using authenticated user for notification.\")\n+\n+    # If request is provided, use the authenticated user as the actor\n+    if request and request.user.is_authenticated:\n+        actor = request.user\n+        print(f\"Authenticated user used as actor: {actor}\")\n+    \n+    # Ensure actor is not None before proceeding with notification\n+    if actor is None:\n+        print(f\"Actor is None, skipping notification.\")\n+        return\n+\n+    # Logging the action details for debugging\n+    print(f\"Sending notification: actor={actor}, recipient={recipient}, verb={verb}, description={description}\")\n+\n+    # Check for permissions if actor is available (ensure the actor has permissions)\n+    if actor and request:\n+        content_type = ContentType.objects.get_for_model(instance)\n+        has_permission = request.user.has_perm(f'{content_type.app_label}.view_{content_type.model}') or \\\n+                         request.user.has_perm(f'{content_type.app_label}.change_{content_type.model}') or \\\n+                         request.user.has_perm(f'{content_type.app_label}.delete_{content_type.model}')\n+\n+        if not has_permission:\n+            print(f\"User {actor.username} does not have permission to {action} {model_name}. Skipping notification.\")\n+            return\n+\n+    # If no specific recipient is provided, send to all users\n+    if recipient is None:\n+        all_users = User.objects.all()\n+        for user in all_users:\n+            # Save the notification data\n+            notify.send(actor, recipient=user, verb=verb, description=description)\n+            print(f\"Notification sent to {user} for action {action}\")\n+    else:\n+        # Save the notification data\n+        notify.send(actor, recipient=recipient, verb=verb, description=description)\n+        print(f\"Notification sent to {recipient} for action {action}\")\n+\n+    # Print model data after saving\n+    print(f\"Notification saved in model: {actor}, {recipient}, {verb}, {description}\")\n+\n+\n+\n+# ðŸ“Œ Handle post_save signals (for creation or updates)\n+@receiver(post_save)\n+def handle_save(sender, instance, created, **kwargs):\n+    action = 'created' if created else 'updated'\n+    \n+    # Log the model name and action for debugging purposes\n+    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n+\n+    send_notification(instance, action, recipient=None, request=kwargs.get('request'))\n+\n+# ðŸ“Œ Handle post_delete signals (for deletions)\n+@receiver(post_delete)\n+def handle_delete(sender, instance, **kwargs):\n+    # Log the model name and deletion for debugging purposes\n+    print(f\"Deleting {instance.__class__.__name__} instance\")\n+    \n+    send_notification(instance, action='deleted', recipient=None, request=kwargs.get('request'))\n+\n+# ðŸ“Œ Dynamically connect signals for all models\n+def connect_signals():\n+    for model in apps.get_models():  # Fetch all models dynamically\n+        if hasattr(model, 'user'):  # Filter models that have a `user` field\n+            post_save.connect(handle_save, sender=model)\n+            post_delete.connect(handle_delete, sender=model)\n+            print(f\"Connected signals for model: {model.__name__}\")\n+\n+# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n+connect_signals()\n+\n"
                },
                {
                    "date": 1739696648162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,19 +75,8 @@\n \n     # Logging the action details for debugging\n     print(f\"Sending notification: actor={actor}, recipient={recipient}, verb={verb}, description={description}\")\n \n-    # Check for permissions if actor is available (ensure the actor has permissions)\n-    if actor and request:\n-        content_type = ContentType.objects.get_for_model(instance)\n-        has_permission = request.user.has_perm(f'{content_type.app_label}.view_{content_type.model}') or \\\n-                         request.user.has_perm(f'{content_type.app_label}.change_{content_type.model}') or \\\n-                         request.user.has_perm(f'{content_type.app_label}.delete_{content_type.model}')\n-\n-        if not has_permission:\n-            print(f\"User {actor.username} does not have permission to {action} {model_name}. Skipping notification.\")\n-            return\n-\n     # If no specific recipient is provided, send to all users\n     if recipient is None:\n         all_users = User.objects.all()\n         for user in all_users:\n@@ -103,137 +92,9 @@\n     print(f\"Notification saved in model: {actor}, {recipient}, {verb}, {description}\")\n \n \n \n-# ðŸ“Œ Handle post_save signals (for creation or updates)\n-@receiver(post_save)\n-def handle_save(sender, instance, created, **kwargs):\n-    action = 'created' if created else 'updated'\n-    \n-    # Log the model name and action for debugging purposes\n-    print(f\"Saving {instance.__class__.__name__} instance, Action: {action}\")\n \n-    send_notification(instance, action, recipient=None, request=kwargs.get('request'))\n-\n-# ðŸ“Œ Handle post_delete signals (for deletions)\n-@receiver(post_delete)\n-def handle_delete(sender, instance, **kwargs):\n-    # Log the model name and deletion for debugging purposes\n-    print(f\"Deleting {instance.__class__.__name__} instance\")\n-    \n-    send_notification(instance, action='deleted', recipient=None, request=kwargs.get('request'))\n-\n-# ðŸ“Œ Dynamically connect signals for all models\n-def connect_signals():\n-    for model in apps.get_models():  # Fetch all models dynamically\n-        if hasattr(model, 'user'):  # Filter models that have a `user` field\n-            post_save.connect(handle_save, sender=model)\n-            post_delete.connect(handle_delete, sender=model)\n-            print(f\"Connected signals for model: {model.__name__}\")\n-\n-# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\n-connect_signals()\n-\n-from django.db.models.signals import post_save, post_delete\n-from django.dispatch import receiver\n-from notifications.signals import notify\n-from django.apps import apps\n-from django.contrib.auth import get_user_model\n-import logging\n-from mainproj.permissions import get_group_permissions\n-from accounts.models import CustomUser as User\n-from django.contrib.admin.models import LogEntry\n-from notifications.models import Notification  \n-from django.contrib.contenttypes.models import ContentType\n-from django.utils.timezone import now\n-\n-# Logger setup for debugging\n-logger = logging.getLogger(__name__)\n-\n-# Action-to-Permission Mapping\n-ACTION_PERMISSION_MAPPING = {\n-    \"list\": \"view\",  \n-    \"retrieve\": \"view\",\n-    \"create\": \"add\",\n-    \"update\": \"change\",\n-    \"partial_update\": \"change\",\n-    \"destroy\": \"delete\",\n-}\n-\n-# Function to send notifications based on permissions and action\n-# Function to send notifications based on permissions and action\n-def send_notification(instance, action, recipient=None, additional_info=None, request=None):\n-    \"\"\" Sends notifications for all CRUD actions (only to the relevant user) \"\"\"\n-    \n-    # Skip notifications for LogEntry (admin activity logs)\n-    if isinstance(instance, LogEntry):\n-        return\n-\n-    # Ensure that the instance is not None\n-    if instance is None:\n-        print(f\"Received None instance. Skipping notification.\")\n-        return\n-\n-    model_name = instance._meta.model_name  # This will return the lowercased name of the model\n-\n-    # Construct the message based on the action\n-    if action == 'created':\n-        verb = \"created\"\n-        description = f\"A new {model_name.capitalize()} was created.\"\n-    elif action == 'updated':\n-        verb = \"updated\"\n-        description = f\"The {model_name.capitalize()} was updated.\"\n-    elif action == 'deleted':\n-        verb = \"deleted\"\n-        description = f\"The {model_name.capitalize()} was deleted.\"\n-\n-    # Add additional info to description if available\n-    if additional_info:\n-        description += f\" Additional Info: {additional_info}\"\n-\n-    # Ensure that the instance has a 'user' attribute, otherwise skip\n-    actor = getattr(instance, 'user', None)\n-    \n-    if actor:\n-        print(f\"Actor found for instance {instance}: {actor}\")\n-    else:\n-        print(f\"No actor found for instance {instance}. Using authenticated user for notification.\")\n-\n-    # If request is provided, use the authenticated user as the actor\n-    if request and request.user.is_authenticated:\n-        actor = request.user\n-        print(f\"Authenticated user used as actor: {actor}\")\n-    \n-    # Logging the action details for debugging\n-    print(f\"Sending notification: actor={actor}, recipient={recipient}, verb={verb}, description={description}\")\n-\n-    # Check for permissions if actor is available (ensure the actor has permissions)\n-    if actor and request:\n-        content_type = ContentType.objects.get_for_model(instance)\n-        has_permission = request.user.has_perm(f'{content_type.app_label}.view_{content_type.model}') or \\\n-                         request.user.has_perm(f'{content_type.app_label}.change_{content_type.model}') or \\\n-                         request.user.has_perm(f'{content_type.app_label}.delete_{content_type.model}')\n-\n-        if not has_permission:\n-            print(f\"User {actor.username} does not have permission to {action} {model_name}. Skipping notification.\")\n-            return\n-\n-    # If no specific recipient is provided, send to all users\n-    if recipient is None:\n-        all_users = User.objects.all()\n-        for user in all_users:\n-            # Save the notification data\n-            notify.send(actor, recipient=user, verb=verb, description=description)\n-            print(f\"Notification sent to {user} for action {action}\")\n-    else:\n-        # Save the notification data\n-        notify.send(actor, recipient=recipient, verb=verb, description=description)\n-        print(f\"Notification sent to {recipient} for action {action}\")\n-\n-    # Print model data after saving\n-    print(f\"Notification saved in model: {actor}, {recipient}, {verb}, {description}\")\n-\n-\n # ðŸ“Œ Handle post_save signals (for creation or updates)\n @receiver(post_save)\n def handle_save(sender, instance, created, **kwargs):\n     action = 'created' if created else 'updated'\n"
                }
            ],
            "date": 1739685589715,
            "name": "Commit-0",
            "content": "from django.db.models.signals import post_save, post_delete\nfrom django.dispatch import receiver\nfrom notifications.signals import notify\nfrom django.apps import apps\nfrom django.contrib.auth.models import User\n\n# ðŸ“Œ Generic function to send notifications\ndef send_notification(instance, action, recipient=None, additional_info=None):\n    \"\"\" Sends notifications for all CRUD actions \"\"\"\n    actor = instance.user if hasattr(instance, 'user') else None  # The actor (could be the creator or user)\n    \n    if not recipient:\n        recipient = User.objects.all()  # You can customize this to target specific users\n    \n    # Message template based on action\n    if action == 'created':\n        verb = \"created\"\n        description = f\"A new {instance.__class__.__name__} was created.\"\n    elif action == 'updated':\n        verb = \"updated\"\n        description = f\"The {instance.__class__.__name__} was updated.\"\n    elif action == 'deleted':\n        verb = \"deleted\"\n        description = f\"The {instance.__class__.__name__} was deleted.\"\n\n    # Add additional info to description if available\n    if additional_info:\n        description += f\" Additional Info: {additional_info}\"\n\n    # Send notification\n    notify.send(\n        actor,  # The user who triggered the action (optional)\n        recipient=recipient,\n        verb=verb,\n        description=description\n    )\n\n# ðŸ“Œ Dynamically connect signals for all models\ndef connect_signals():\n    for model in apps.get_models():  # Get all models in the project\n        if hasattr(model, 'user'):  # Filter models with 'user' field (you can modify this)\n            # Handle post_save (creation and updates)\n            post_save.connect(handle_save, sender=model)\n\n            # Handle post_delete (deletion)\n            post_delete.connect(handle_delete, sender=model)\n\n# ðŸ“Œ Handle post_save signals (for creation or updates)\n@receiver(post_save)\ndef handle_save(sender, instance, created, **kwargs):\n    action = 'created' if created else 'updated'\n    send_notification(instance, action, recipient=None)\n\n# ðŸ“Œ Handle post_delete signals (for deletions)\n@receiver(post_delete)\ndef handle_delete(sender, instance, **kwargs):\n    send_notification(instance, action='deleted', recipient=None)\n\n# ðŸ“Œ Automatically call connect_signals function to register signals when Django starts\nconnect_signals()\n"
        }
    ]
}