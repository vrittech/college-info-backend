{
    "sourceFile": "accounts/serializers/custom_user_serializers.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 48,
            "patches": [
                {
                    "date": 1728378543651,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1738219558783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,136 +1,149 @@\n from rest_framework import serializers\n-from django.contrib.auth.models import Group,Permission\n-from ..models import CustomUser\n-from django.contrib.auth.hashers import make_password\n-from ...accountsmanagement import roles\n-from ..utilities.permission import SecureFields\n+from django.contrib.auth import get_user_model\n+# from department.models import Department\n+from django.contrib.auth.models import Group, Permission\n+from django.contrib.auth.hashers import check_password, make_password\n+# from socialmedia.models import SocialMedia,StaffHaveSocialMedia\n+from accounts.models import CustomUser\n \n-class CustomUserReadSerializer(serializers.ModelSerializer):\n+\n+User = get_user_model()\n+\n+# class SocialMediaSerializer(serializers.ModelSerializer):\n+#     class Meta:\n+#         model = SocialMedia\n+#         fields = ['id','name', 'url', 'media', 'created_at', 'updated_at' ]  # Adjust fields as per your SocialMedia model\n+\n+# class StaffSocialMediaSerializer(serializers.ModelSerializer):\n+#     social_media = SocialMediaSerializer(read_only=True)\n+\n+#     class Meta:\n+#         model = StaffHaveSocialMedia\n+#         fields = ['social_media', 'social_media_url','created_at', 'updated_at']\n+\n+class PermissionSerializer(serializers.ModelSerializer):\n     class Meta:\n-        ref_name =  \"account serializers\"\n-        model = CustomUser\n-        # fields = '__all__' \n-        exclude = ['password']\n+        ref_name = \"group\"\n+        model = Permission\n+        fields = ['id', 'name', 'codename']\n+        \n+class GroupSerializer(serializers.ModelSerializer):\n+    # permissions = PermissionSerializer(many=True, read_only=True)\n+    class Meta:\n+        model = Group\n+        fields = ['id', 'name']\n+        ref_name='user_groups'\n \n-class CustomUserReadLimitedSerializer(serializers.ModelSerializer):\n+# class DepartmentSerializer(serializers.ModelSerializer):\n+#     class Meta:\n+#         model = Department\n+#         fields = ['id','name']\n+\n+class CustomUserReadSerializer(serializers.ModelSerializer):\n+    # department = DepartmentSerializer(read_only = True)\n+    groups = GroupSerializer(many=True,read_only = True)\n+    # usersocial = StaffSocialMediaSerializer(many=True,read_only = True)\n     class Meta:\n-        ref_name =  \"CustomUserReadLimitedSerializer serializers\"\n-        model = CustomUser\n-        fields = ['id','email','first_name','username',] \n+        model = User\n+        fields = '__all__'\n+        \n+    \n \n-class CustomUserReadLimitedSerializer_1(serializers.ModelSerializer):\n+class CustomUserWriteSerializer(serializers.ModelSerializer):\n+    groups = serializers.PrimaryKeyRelatedField(queryset=Group.objects.all(), many=True, required=False)\n+    # usersocial = StaffSocialMediaSerializer(many=True, required=False)\n+    \n+\n     class Meta:\n-        ref_name =  \"CustomUserReadLimitedSerializer serializers\"\n-        model = CustomUser\n-        fields = ['id','email','first_name','username','last_name','role','getRoleName']\n+        model = User\n+        fields = '__all__'\n+        extra_kwargs = {\n+            'password': {'write_only': True}\n+        }\n+        \n+    def validate(self, data):\n+        # Check if the position already exists in another Career\n+        position = data.get('position')\n+        if position and CustomUser.objects.filter(position=position).exists():\n+            raise serializers.ValidationError({\"position\": \"A user with this position already exists.\"})\n+        return data\n \n+    def create(self, validated_data):\n+    groups = validated_data.pop('groups', [])\n+    social_media_data = validated_data.pop('social_media', [])\n+    password = validated_data.pop('password', None)\n \n-class CustomUserSerializer(serializers.ModelSerializer):\n+    # Create user\n+    user = User.objects.create(**validated_data)\n     \n-    def validate_password(self,value):#field level validation\n-        if len(value) < 5:\n-            raise serializers.ValidationError('Password must be 8 digit')\n-        return make_password(value) \n+    if password:\n+        user.set_password(password)\n+\n+    # Convert groups into primary keys if they are objects\n+    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n     \n-    def validate_role(self,value):#field level validation\n-        user = self.context['request'].user\n-        # print(user.is_authenticated)\n-        if not user.is_authenticated:\n-            if value == roles.USER:\n-                pass\n-            else:\n-                raise serializers.ValidationError(\"You can only set USER,PUBLISHER as role\") \n-        elif user.role in [roles.ADMIN,roles.SUPER_ADMIN]:\n-            return value\n-        elif user.is_authenticated and value!=roles.USER:\n-                raise serializers.ValidationError(\"You can only set USER as role\") \n-        return value\n-    \n-    def validate_is_verified(self,value):\n+    user.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n+    user.save()\n \n-        user = self.context['request'].user\n-        if user.is_authenticated:\n-            if user.role == roles.ADMIN:\n-                return value\n-            else:\n-                return False\n-        else:\n-            return False\n+    return user\n \n-    def validate_is_superuser(self,value):\n\\ No newline at end of file\n-        if value == True:\n-            raise serializers.ValidationError(\"You can not set USER as SYSTEM_ADMIN\") \n-        else:\n-            return False\n+        # # Create social media records\n+        # for sm_data in social_media_data:\n+        #     StaffHaveSocialMedia.objects.create(\n+        #         staff=user,\n+        #         social_media=sm_data['social_media'],\n+        #         social_media_url=sm_data['social_media_url']\n+        #     )\n \n-    def validate(self, attrs):\n-        request = self.context.get('request')\n-        action = self.context['view'].action     \n+        return user\n \n-        if action == 'partial_update':\n-            old_password = request.data.get('old_password')  \n-            if old_password is not None:      \n-                instance = self.instance\n-                if not instance.check_password(old_password):\n-                    raise serializers.ValidationError(\"Password does not match\")\n-            attrs['old_password_change_case'] = True\n-        return attrs        \n+    def update(self, instance, validated_data):\n+        groups = validated_data.pop('groups', [])\n+        social_media_data = validated_data.pop('social_media', [])\n+        password = validated_data.pop('password', None)\n \n-    def get_extra_kwargs(self):\n-        extra_kwargs = super().get_extra_kwargs()\n-        try:\n-            if self.context['request'].method == 'PUT':\n-                extra_kwargs['password'] = {'required': False}\n-            return extra_kwargs\n-        except:\n-            pass\n-    \n-    class Meta:\n-        ref_name =  \"accountWriteserializer\"\n-        model = CustomUser\n-        fields = '__all__' \n+        # Update user fields\n+        for attr, value in validated_data.items():\n+            setattr(instance, attr, value)\n \n+        if password:\n+            instance.set_password(password)\n+        instance.groups.set(groups)\n+        instance.save()\n \n-    def get_fields(self):\n-        model_fields = super().get_fields()\n-        SecureFields(self,model_fields,['email','is_active','is_verified','role','provider','username','is_superuser'],['PATCH','PUT'],[roles.ADMIN,roles.SUPER_ADMIN])\n-        # SecureFields(self,model_fields,['provider'],['PATCH','PUT'],[]) #if empty [] it means it is striction for all\n-        return model_fields\n+        # Update or create social media records\n+        # for sm_data in social_media_data:\n+        #     StaffHaveSocialMedia.objects.update_or_create(\n+        #         staff=instance,\n+        #         social_media=sm_data['social_media'],\n+        #         defaults={'social_media_url': sm_data['social_media_url']}\n+        #     )\n \n-class RoleSerializer(serializers.Serializer):\n-    role_id = serializers.IntegerField()\n-    role_name = serializers.CharField()\n-    def to_representation(self, instance):\n-        return {'role_id': instance[0], 'role_name': instance[1]}\n+        return instance\n \n-\n-class GroupSerializer(serializers.ModelSerializer):\n+class CustomUserRetrieveSerializer(serializers.ModelSerializer):\n+    # usersocial = StaffSocialMediaSerializer(many=True,read_only = True)\n+    groups = GroupSerializer(many=True,read_only = True)\n+    # department = DepartmentSerializer(read_only = True)\n     class Meta:\n-        model = Group\n-        fields = '__all__'  \n+        model = User\n+        fields =fields = '__all__'\n+        # ('roles', 'department', 'email', 'full_name', 'social_links', 'position', 'phone', 'avatar', 'professional_image', )\n \n-class PermissionSerializer(serializers.ModelSerializer):\n-    class Meta:\n-        model = Permission\n-        fields = '__all__'  \n+class CustomUserChangePasswordSerializers(serializers.Serializer):\n+    current_password = serializers.CharField(write_only=True)\n+    new_password = serializers.CharField(write_only=True)\n \n-class LoginSerializer(serializers.Serializer):\n-    email = serializers.EmailField()\n-    username = serializers.CharField()\n-    password = serializers.CharField()\n+    def validate(self, data):\n+        user = self.context['request'].user\n+        # Check if current password is correct\n+        if not check_password(data['current_password'], user.password):\n+            raise serializers.ValidationError({\"current_password\": \"Current password is incorrect\"})\n+        return data\n \n-class GroupNamesSerializer(serializers.Serializer):\n-    group_names = serializers.ListField(child=serializers.CharField())\n+    def validate_new_password(self, value):\n+        if len(value) < 8:\n+            raise serializers.ValidationError(\"Password must be at least 8 characters long\")\n+        return value\n \n-class PermissionGroupSerializer(serializers.Serializer):\n-    permission_id = serializers.IntegerField()\n-    groups = serializers.DictField(child=serializers.BooleanField())\n-\n-\n-class UserDetailsSerializer(serializers.ModelSerializer):\n-    class Meta:\n-        model = CustomUser\n-        fields = ['id', 'full_name', 'phone', 'image', 'email']\n-    \n-  \n-    \n+   \n\\ No newline at end of file\n"
                },
                {
                    "date": 1738219566661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,25 +68,24 @@\n             raise serializers.ValidationError({\"position\": \"A user with this position already exists.\"})\n         return data\n \n     def create(self, validated_data):\n-    groups = validated_data.pop('groups', [])\n-    social_media_data = validated_data.pop('social_media', [])\n-    password = validated_data.pop('password', None)\n+        groups = validated_data.pop('groups', [])\n+        social_media_data = validated_data.pop('social_media', [])\n+        password = validated_data.pop('password', None)\n \n-    # Create user\n-    user = User.objects.create(**validated_data)\n-    \n-    if password:\n-        user.set_password(password)\n+        # Create user\n+        user = User.objects.create(**validated_data)\n+        \n+        if password:\n+            user.set_password(password)\n \n-    # Convert groups into primary keys if they are objects\n-    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-    \n-    user.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n-    user.save()\n+        # Convert groups into primary keys if they are objects\n+        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+        \n+        user.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n+        user.save()\n \n-    return user\n \n         # # Create social media records\n         # for sm_data in social_media_data:\n         #     StaffHaveSocialMedia.objects.create(\n"
                },
                {
                    "date": 1738219687766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,31 +96,27 @@\n \n         return user\n \n     def update(self, instance, validated_data):\n-        groups = validated_data.pop('groups', [])\n-        social_media_data = validated_data.pop('social_media', [])\n-        password = validated_data.pop('password', None)\n+    groups = validated_data.pop('groups', [])\n+    social_media_data = validated_data.pop('social_media', [])\n+    password = validated_data.pop('password', None)\n \n-        # Update user fields\n-        for attr, value in validated_data.items():\n-            setattr(instance, attr, value)\n+    # Update user fields\n+    for attr, value in validated_data.items():\n+        setattr(instance, attr, value)\n \n-        if password:\n-            instance.set_password(password)\n-        instance.groups.set(groups)\n-        instance.save()\n+    if password:\n+        instance.set_password(password)\n \n-        # Update or create social media records\n-        # for sm_data in social_media_data:\n-        #     StaffHaveSocialMedia.objects.update_or_create(\n-        #         staff=instance,\n-        #         social_media=sm_data['social_media'],\n-        #         defaults={'social_media_url': sm_data['social_media_url']}\n-        #     )\n+    # Convert groups into primary keys if they are objects\n+    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n \n-        return instance\n+    instance.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n+    instance.save()\n \n+    return instance\n+\n class CustomUserRetrieveSerializer(serializers.ModelSerializer):\n     # usersocial = StaffSocialMediaSerializer(many=True,read_only = True)\n     groups = GroupSerializer(many=True,read_only = True)\n     # department = DepartmentSerializer(read_only = True)\n"
                },
                {
                    "date": 1738219789457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,54 +68,45 @@\n             raise serializers.ValidationError({\"position\": \"A user with this position already exists.\"})\n         return data\n \n     def create(self, validated_data):\n-        groups = validated_data.pop('groups', [])\n-        social_media_data = validated_data.pop('social_media', [])\n-        password = validated_data.pop('password', None)\n+    groups = validated_data.pop('groups', [])\n+    social_media_data = validated_data.pop('social_media', [])\n+    password = validated_data.pop('password', None)\n \n-        # Create user\n-        user = User.objects.create(**validated_data)\n-        \n-        if password:\n-            user.set_password(password)\n+    # Create user\n+    user = User.objects.create(**validated_data)\n+    \n+    if password:\n+        user.set_password(password)\n \n-        # Convert groups into primary keys if they are objects\n+    # Ensure groups only contain IDs\n+    if groups:\n         group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-        \n-        user.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n-        user.save()\n+        user.groups.set(group_ids)  # ✅ Corrected usage\n \n+    user.save()\n+    return user\n \n-        # # Create social media records\n-        # for sm_data in social_media_data:\n-        #     StaffHaveSocialMedia.objects.create(\n-        #         staff=user,\n-        #         social_media=sm_data['social_media'],\n-        #         social_media_url=sm_data['social_media_url']\n-        #     )\n-\n-        return user\n-\n     def update(self, instance, validated_data):\n-    groups = validated_data.pop('groups', [])\n-    social_media_data = validated_data.pop('social_media', [])\n-    password = validated_data.pop('password', None)\n+        groups = validated_data.pop('groups', [])\n+        social_media_data = validated_data.pop('social_media', [])\n+        password = validated_data.pop('password', None)\n \n-    # Update user fields\n-    for attr, value in validated_data.items():\n-        setattr(instance, attr, value)\n+        # Update user fields\n+        for attr, value in validated_data.items():\n+            setattr(instance, attr, value)\n \n-    if password:\n-        instance.set_password(password)\n+        if password:\n+            instance.set_password(password)\n \n-    # Convert groups into primary keys if they are objects\n-    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+        # Convert groups into primary keys if they are objects\n+        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n \n-    instance.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n-    instance.save()\n+        instance.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n+        instance.save()\n \n-    return instance\n+        return instance\n \n class CustomUserRetrieveSerializer(serializers.ModelSerializer):\n     # usersocial = StaffSocialMediaSerializer(many=True,read_only = True)\n     groups = GroupSerializer(many=True,read_only = True)\n"
                },
                {
                    "date": 1738219810660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,25 +68,25 @@\n             raise serializers.ValidationError({\"position\": \"A user with this position already exists.\"})\n         return data\n \n     def create(self, validated_data):\n-    groups = validated_data.pop('groups', [])\n-    social_media_data = validated_data.pop('social_media', [])\n-    password = validated_data.pop('password', None)\n+        groups = validated_data.pop('groups', [])\n+        social_media_data = validated_data.pop('social_media', [])\n+        password = validated_data.pop('password', None)\n \n-    # Create user\n-    user = User.objects.create(**validated_data)\n-    \n-    if password:\n-        user.set_password(password)\n+        # Create user\n+        user = User.objects.create(**validated_data)\n+        \n+        if password:\n+            user.set_password(password)\n \n-    # Ensure groups only contain IDs\n-    if groups:\n-        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-        user.groups.set(group_ids)  # ✅ Corrected usage\n+        # Ensure groups only contain IDs\n+        if groups:\n+            group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+            user.groups.set(group_ids)  \n \n-    user.save()\n-    return user\n+        user.save()\n+        return user\n \n     def update(self, instance, validated_data):\n         groups = validated_data.pop('groups', [])\n         social_media_data = validated_data.pop('social_media', [])\n"
                },
                {
                    "date": 1738219817428,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,8 +80,9 @@\n             user.set_password(password)\n \n         # Ensure groups only contain IDs\n         if groups:\n+            print(groups)\n             group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n             user.groups.set(group_ids)  \n \n         user.save()\n"
                },
                {
                    "date": 1738219824489,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,9 @@\n             user.set_password(password)\n \n         # Ensure groups only contain IDs\n         if groups:\n-            print(groups)\n+            print(groups,\"!!!!!!!!!!!!!!!!!!!!\")\n             group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n             user.groups.set(group_ids)  \n \n         user.save()\n"
                },
                {
                    "date": 1738219851653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,8 +69,9 @@\n         return data\n \n     def create(self, validated_data):\n         groups = validated_data.pop('groups', [])\n+        \n         social_media_data = validated_data.pop('social_media', [])\n         password = validated_data.pop('password', None)\n \n         # Create user\n"
                },
                {
                    "date": 1738219858192,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,9 +69,9 @@\n         return data\n \n     def create(self, validated_data):\n         groups = validated_data.pop('groups', [])\n-        \n+        print(groups,\"!!!!!!!!!!!!!!!!!!!!\")\n         social_media_data = validated_data.pop('social_media', [])\n         password = validated_data.pop('password', None)\n \n         # Create user\n"
                },
                {
                    "date": 1738219865908,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,9 +69,9 @@\n         return data\n \n     def create(self, validated_data):\n         groups = validated_data.pop('groups', [])\n-        print(groups,\"!!!!!!!!!!!!!!!!!!!!\")\n+        print(groups,\"---------------------\")\n         social_media_data = validated_data.pop('social_media', [])\n         password = validated_data.pop('password', None)\n \n         # Create user\n"
                },
                {
                    "date": 1738220003260,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,48 +67,48 @@\n         if position and CustomUser.objects.filter(position=position).exists():\n             raise serializers.ValidationError({\"position\": \"A user with this position already exists.\"})\n         return data\n \n-    def create(self, validated_data):\n-        groups = validated_data.pop('groups', [])\n-        print(groups,\"---------------------\")\n-        social_media_data = validated_data.pop('social_media', [])\n-        password = validated_data.pop('password', None)\n+    # def create(self, validated_data):\n+    #     groups = validated_data.pop('groups', [])\n+    #     print(groups,\"---------------------\")\n+    #     social_media_data = validated_data.pop('social_media', [])\n+    #     password = validated_data.pop('password', None)\n \n-        # Create user\n-        user = User.objects.create(**validated_data)\n+    #     # Create user\n+    #     user = User.objects.create(**validated_data)\n         \n-        if password:\n-            user.set_password(password)\n+    #     if password:\n+    #         user.set_password(password)\n \n-        # Ensure groups only contain IDs\n-        if groups:\n-            print(groups,\"!!!!!!!!!!!!!!!!!!!!\")\n-            group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-            user.groups.set(group_ids)  \n+    #     # Ensure groups only contain IDs\n+    #     if groups:\n+    #         print(groups,\"!!!!!!!!!!!!!!!!!!!!\")\n+    #         group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+    #         user.groups.set(group_ids)  \n \n-        user.save()\n-        return user\n+    #     user.save()\n+    #     return user\n \n-    def update(self, instance, validated_data):\n-        groups = validated_data.pop('groups', [])\n-        social_media_data = validated_data.pop('social_media', [])\n-        password = validated_data.pop('password', None)\n+    # def update(self, instance, validated_data):\n+    #     groups = validated_data.pop('groups', [])\n+    #     social_media_data = validated_data.pop('social_media', [])\n+    #     password = validated_data.pop('password', None)\n \n-        # Update user fields\n-        for attr, value in validated_data.items():\n-            setattr(instance, attr, value)\n+    #     # Update user fields\n+    #     for attr, value in validated_data.items():\n+    #         setattr(instance, attr, value)\n \n-        if password:\n-            instance.set_password(password)\n+    #     if password:\n+    #         instance.set_password(password)\n \n-        # Convert groups into primary keys if they are objects\n-        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+    #     # Convert groups into primary keys if they are objects\n+    #     group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n \n-        instance.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n-        instance.save()\n+    #     instance.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n+    #     instance.save()\n \n-        return instance\n+    #     return instance\n \n class CustomUserRetrieveSerializer(serializers.ModelSerializer):\n     # usersocial = StaffSocialMediaSerializer(many=True,read_only = True)\n     groups = GroupSerializer(many=True,read_only = True)\n"
                },
                {
                    "date": 1739428550934,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,14 +60,8 @@\n         extra_kwargs = {\n             'password': {'write_only': True}\n         }\n         \n-    def validate(self, data):\n-        # Check if the position already exists in another Career\n-        position = data.get('position')\n-        if position and CustomUser.objects.filter(position=position).exists():\n-            raise serializers.ValidationError({\"position\": \"A user with this position already exists.\"})\n-        return data\n \n     # def create(self, validated_data):\n     #     groups = validated_data.pop('groups', [])\n     #     print(groups,\"---------------------\")\n"
                },
                {
                    "date": 1739428576567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,58 @@\n from accounts.models import CustomUser\n \n \n User = get_user_model()\n+def str_to_list(data, value_to_convert):\n+    try:\n+        mutable_data = data.dict()  # Convert to dictionary if possible\n+    except AttributeError:\n+        mutable_data = data  # Already a dictionary\n \n+    value_to_convert_data = mutable_data.get(value_to_convert)\n+\n+    # If it's already a list, return as is\n+    if isinstance(value_to_convert_data, list):\n+        return mutable_data\n+\n+    # Handle binary or file data (leave as is)\n+    if isinstance(value_to_convert_data, bytes):\n+        return mutable_data\n+\n+    # If it's an int, float, or bool, wrap it in a list\n+    if isinstance(value_to_convert_data, (int, float, bool)):\n+        mutable_data[value_to_convert] = [value_to_convert_data]\n+        return mutable_data\n+\n+    # If it's None, convert to an empty list\n+    if value_to_convert_data is None:\n+        mutable_data[value_to_convert] = []\n+        return mutable_data\n+\n+    # Handle comma-separated values (e.g., \"4,5\")\n+    if isinstance(value_to_convert_data, str) and \",\" in value_to_convert_data:\n+        parsed_list = [item.strip() for item in value_to_convert_data.split(\",\")]\n+        # Convert to integers if possible\n+        mutable_data[value_to_convert] = [int(item) if item.isdigit() else item for item in parsed_list]\n+        return mutable_data\n+\n+    # If it's a string, try parsing it as a list\n+    try:\n+        parsed_value = ast.literal_eval(value_to_convert_data)\n+\n+        # Ensure parsed result is a list\n+        if isinstance(parsed_value, list):\n+            mutable_data[value_to_convert] = parsed_value\n+        else:\n+            # Convert string (that is not a list) into a single-item list\n+            mutable_data[value_to_convert] = [value_to_convert_data]\n+\n+        return mutable_data\n+\n+    except (ValueError, SyntaxError):\n+        # If parsing fails, wrap it in a list instead\n+        mutable_data[value_to_convert] = [value_to_convert_data]\n+        return mutable_data\n # class SocialMediaSerializer(serializers.ModelSerializer):\n #     class Meta:\n #         model = SocialMedia\n #         fields = ['id','name', 'url', 'media', 'created_at', 'updated_at' ]  # Adjust fields as per your SocialMedia model\n"
                },
                {
                    "date": 1739428584284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,9 @@\n from accounts.models import CustomUser\n \n \n User = get_user_model()\n+\n def str_to_list(data, value_to_convert):\n     try:\n         mutable_data = data.dict()  # Convert to dictionary if possible\n     except AttributeError:\n@@ -57,8 +58,9 @@\n     except (ValueError, SyntaxError):\n         # If parsing fails, wrap it in a list instead\n         mutable_data[value_to_convert] = [value_to_convert_data]\n         return mutable_data\n+    \n # class SocialMediaSerializer(serializers.ModelSerializer):\n #     class Meta:\n #         model = SocialMedia\n #         fields = ['id','name', 'url', 'media', 'created_at', 'updated_at' ]  # Adjust fields as per your SocialMedia model\n"
                },
                {
                    "date": 1739428634860,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,9 +105,9 @@\n     # usersocial = StaffSocialMediaSerializer(many=True, required=False)\n     \n \n     class Meta:\n-        model = User\n+        model = CustomUser\n         fields = '__all__'\n         extra_kwargs = {\n             'password': {'write_only': True}\n         }\n"
                },
                {
                    "date": 1739428641444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,9 +94,9 @@\n     # department = DepartmentSerializer(read_only = True)\n     groups = GroupSerializer(many=True,read_only = True)\n     # usersocial = StaffSocialMediaSerializer(many=True,read_only = True)\n     class Meta:\n-        model = User\n+        model = CustomUser\n         fields = '__all__'\n         \n     \n \n@@ -158,9 +158,9 @@\n     # usersocial = StaffSocialMediaSerializer(many=True,read_only = True)\n     groups = GroupSerializer(many=True,read_only = True)\n     # department = DepartmentSerializer(read_only = True)\n     class Meta:\n-        model = User\n+        model = CustomUser\n         fields =fields = '__all__'\n         # ('roles', 'department', 'email', 'full_name', 'social_links', 'position', 'phone', 'avatar', 'professional_image', )\n \n class CustomUserChangePasswordSerializers(serializers.Serializer):\n"
                },
                {
                    "date": 1739428667367,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -112,48 +112,48 @@\n             'password': {'write_only': True}\n         }\n         \n \n-    # def create(self, validated_data):\n-    #     groups = validated_data.pop('groups', [])\n-    #     print(groups,\"---------------------\")\n-    #     social_media_data = validated_data.pop('social_media', [])\n-    #     password = validated_data.pop('password', None)\n+    def create(self, validated_data):\n+        groups = validated_data.pop('groups', [])\n+        print(groups,\"---------------------\")\n+        social_media_data = validated_data.pop('social_media', [])\n+        password = validated_data.pop('password', None)\n \n-    #     # Create user\n-    #     user = User.objects.create(**validated_data)\n+        # Create user\n+        user = User.objects.create(**validated_data)\n         \n-    #     if password:\n-    #         user.set_password(password)\n+        if password:\n+            user.set_password(password)\n \n-    #     # Ensure groups only contain IDs\n-    #     if groups:\n-    #         print(groups,\"!!!!!!!!!!!!!!!!!!!!\")\n-    #         group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-    #         user.groups.set(group_ids)  \n+        # Ensure groups only contain IDs\n+        if groups:\n+            print(groups,\"!!!!!!!!!!!!!!!!!!!!\")\n+            group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+            user.groups.set(group_ids)  \n \n-    #     user.save()\n-    #     return user\n+        user.save()\n+        return user\n \n-    # def update(self, instance, validated_data):\n-    #     groups = validated_data.pop('groups', [])\n-    #     social_media_data = validated_data.pop('social_media', [])\n-    #     password = validated_data.pop('password', None)\n+    def update(self, instance, validated_data):\n+        groups = validated_data.pop('groups', [])\n+        social_media_data = validated_data.pop('social_media', [])\n+        password = validated_data.pop('password', None)\n \n-    #     # Update user fields\n-    #     for attr, value in validated_data.items():\n-    #         setattr(instance, attr, value)\n+        # Update user fields\n+        for attr, value in validated_data.items():\n+            setattr(instance, attr, value)\n \n-    #     if password:\n-    #         instance.set_password(password)\n+        if password:\n+            instance.set_password(password)\n \n-    #     # Convert groups into primary keys if they are objects\n-    #     group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+        # Convert groups into primary keys if they are objects\n+        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n \n-    #     instance.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n-    #     instance.save()\n+        instance.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n+        instance.save()\n \n-    #     return instance\n+        return instance\n \n class CustomUserRetrieveSerializer(serializers.ModelSerializer):\n     # usersocial = StaffSocialMediaSerializer(many=True,read_only = True)\n     groups = GroupSerializer(many=True,read_only = True)\n"
                },
                {
                    "date": 1739428677008,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -112,55 +112,55 @@\n             'password': {'write_only': True}\n         }\n         \n \n-    def create(self, validated_data):\n-        groups = validated_data.pop('groups', [])\n-        print(groups,\"---------------------\")\n-        social_media_data = validated_data.pop('social_media', [])\n-        password = validated_data.pop('password', None)\n+    # def create(self, validated_data):\n+    #     groups = validated_data.pop('groups', [])\n+    #     print(groups,\"---------------------\")\n+    #     social_media_data = validated_data.pop('social_media', [])\n+    #     password = validated_data.pop('password', None)\n \n-        # Create user\n-        user = User.objects.create(**validated_data)\n+    #     # Create user\n+    #     user = User.objects.create(**validated_data)\n         \n-        if password:\n-            user.set_password(password)\n+    #     if password:\n+    #         user.set_password(password)\n \n-        # Ensure groups only contain IDs\n-        if groups:\n-            print(groups,\"!!!!!!!!!!!!!!!!!!!!\")\n-            group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-            user.groups.set(group_ids)  \n+    #     # Ensure groups only contain IDs\n+    #     if groups:\n+    #         print(groups,\"!!!!!!!!!!!!!!!!!!!!\")\n+    #         group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+    #         user.groups.set(group_ids)  \n \n-        user.save()\n-        return user\n+    #     user.save()\n+    #     return user\n \n-    def update(self, instance, validated_data):\n-        groups = validated_data.pop('groups', [])\n-        social_media_data = validated_data.pop('social_media', [])\n-        password = validated_data.pop('password', None)\n+    # def update(self, instance, validated_data):\n+    #     groups = validated_data.pop('groups', [])\n+    #     social_media_data = validated_data.pop('social_media', [])\n+    #     password = validated_data.pop('password', None)\n \n-        # Update user fields\n-        for attr, value in validated_data.items():\n-            setattr(instance, attr, value)\n+    #     # Update user fields\n+    #     for attr, value in validated_data.items():\n+    #         setattr(instance, attr, value)\n \n-        if password:\n-            instance.set_password(password)\n+    #     if password:\n+    #         instance.set_password(password)\n \n-        # Convert groups into primary keys if they are objects\n-        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+    #     # Convert groups into primary keys if they are objects\n+    #     group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n \n-        instance.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n-        instance.save()\n+    #     instance.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n+    #     instance.save()\n \n-        return instance\n+    #     return instance\n \n class CustomUserRetrieveSerializer(serializers.ModelSerializer):\n     # usersocial = StaffSocialMediaSerializer(many=True,read_only = True)\n     groups = GroupSerializer(many=True,read_only = True)\n     # department = DepartmentSerializer(read_only = True)\n     class Meta:\n-        model = CustomUser\n+        model = User\n         fields =fields = '__all__'\n         # ('roles', 'department', 'email', 'full_name', 'social_links', 'position', 'phone', 'avatar', 'professional_image', )\n \n class CustomUserChangePasswordSerializers(serializers.Serializer):\n"
                },
                {
                    "date": 1739428685204,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n # from department.models import Department\n from django.contrib.auth.models import Group, Permission\n from django.contrib.auth.hashers import check_password, make_password\n # from socialmedia.models import SocialMedia,StaffHaveSocialMedia\n-from accounts.models import CustomUser\n+from accounts.models import CustomUser as User\n \n \n User = get_user_model()\n \n@@ -94,9 +94,9 @@\n     # department = DepartmentSerializer(read_only = True)\n     groups = GroupSerializer(many=True,read_only = True)\n     # usersocial = StaffSocialMediaSerializer(many=True,read_only = True)\n     class Meta:\n-        model = CustomUser\n+        model = User\n         fields = '__all__'\n         \n     \n \n@@ -105,9 +105,9 @@\n     # usersocial = StaffSocialMediaSerializer(many=True, required=False)\n     \n \n     class Meta:\n-        model = CustomUser\n+        model = User\n         fields = '__all__'\n         extra_kwargs = {\n             'password': {'write_only': True}\n         }\n"
                },
                {
                    "date": 1739428695310,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,11 +4,12 @@\n from django.contrib.auth.models import Group, Permission\n from django.contrib.auth.hashers import check_password, make_password\n # from socialmedia.models import SocialMedia,StaffHaveSocialMedia\n from accounts.models import CustomUser as User\n+import ast\n \n \n-User = get_user_model()\n+# User = get_user_model()\n \n def str_to_list(data, value_to_convert):\n     try:\n         mutable_data = data.dict()  # Convert to dictionary if possible\n"
                },
                {
                    "date": 1739428730528,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,8 +104,13 @@\n class CustomUserWriteSerializer(serializers.ModelSerializer):\n     groups = serializers.PrimaryKeyRelatedField(queryset=Group.objects.all(), many=True, required=False)\n     # usersocial = StaffSocialMediaSerializer(many=True, required=False)\n     \n+      def to_internal_value(self, data):\n+        \"\"\"Convert certification input from string to list using str_to_list.\"\"\"\n+        data = str_to_list(data, 'certification')  # Convert string to list for certification\n+        return super().to_internal_value(data)\n+    \n \n     class Meta:\n         model = User\n         fields = '__all__'\n"
                },
                {
                    "date": 1739428738800,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,11 +104,11 @@\n class CustomUserWriteSerializer(serializers.ModelSerializer):\n     groups = serializers.PrimaryKeyRelatedField(queryset=Group.objects.all(), many=True, required=False)\n     # usersocial = StaffSocialMediaSerializer(many=True, required=False)\n     \n-      def to_internal_value(self, data):\n+    def to_internal_value(self, data):\n         \"\"\"Convert certification input from string to list using str_to_list.\"\"\"\n-        data = str_to_list(data, 'certification')  # Convert string to list for certification\n+        data = str_to_list(data, 'groups')  # Convert string to list for certification\n         return super().to_internal_value(data)\n     \n \n     class Meta:\n"
                },
                {
                    "date": 1739428744916,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,9 +105,9 @@\n     groups = serializers.PrimaryKeyRelatedField(queryset=Group.objects.all(), many=True, required=False)\n     # usersocial = StaffSocialMediaSerializer(many=True, required=False)\n     \n     def to_internal_value(self, data):\n-        \"\"\"Convert certification input from string to list using str_to_list.\"\"\"\n+        \"\"\"Convert groups input from string to list using str_to_list.\"\"\"\n         data = str_to_list(data, 'groups')  # Convert string to list for certification\n         return super().to_internal_value(data)\n     \n \n"
                },
                {
                    "date": 1739428755478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,48 +118,48 @@\n             'password': {'write_only': True}\n         }\n         \n \n-    # def create(self, validated_data):\n-    #     groups = validated_data.pop('groups', [])\n-    #     print(groups,\"---------------------\")\n-    #     social_media_data = validated_data.pop('social_media', [])\n-    #     password = validated_data.pop('password', None)\n+    def create(self, validated_data):\n+        groups = validated_data.pop('groups', [])\n+        print(groups,\"---------------------\")\n+        social_media_data = validated_data.pop('social_media', [])\n+        password = validated_data.pop('password', None)\n \n-    #     # Create user\n-    #     user = User.objects.create(**validated_data)\n+        # Create user\n+        user = User.objects.create(**validated_data)\n         \n-    #     if password:\n-    #         user.set_password(password)\n+        if password:\n+            user.set_password(password)\n \n-    #     # Ensure groups only contain IDs\n-    #     if groups:\n-    #         print(groups,\"!!!!!!!!!!!!!!!!!!!!\")\n-    #         group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-    #         user.groups.set(group_ids)  \n+        # Ensure groups only contain IDs\n+        if groups:\n+            print(groups,\"!!!!!!!!!!!!!!!!!!!!\")\n+            group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+            user.groups.set(group_ids)  \n \n-    #     user.save()\n-    #     return user\n+        user.save()\n+        return user\n \n-    # def update(self, instance, validated_data):\n-    #     groups = validated_data.pop('groups', [])\n-    #     social_media_data = validated_data.pop('social_media', [])\n-    #     password = validated_data.pop('password', None)\n+    def update(self, instance, validated_data):\n+        groups = validated_data.pop('groups', [])\n+        social_media_data = validated_data.pop('social_media', [])\n+        password = validated_data.pop('password', None)\n \n-    #     # Update user fields\n-    #     for attr, value in validated_data.items():\n-    #         setattr(instance, attr, value)\n+        # Update user fields\n+        for attr, value in validated_data.items():\n+            setattr(instance, attr, value)\n \n-    #     if password:\n-    #         instance.set_password(password)\n+        if password:\n+            instance.set_password(password)\n \n-    #     # Convert groups into primary keys if they are objects\n-    #     group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+        # Convert groups into primary keys if they are objects\n+        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n \n-    #     instance.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n-    #     instance.save()\n+        instance.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n+        instance.save()\n \n-    #     return instance\n+        return instance\n \n class CustomUserRetrieveSerializer(serializers.ModelSerializer):\n     # usersocial = StaffSocialMediaSerializer(many=True,read_only = True)\n     groups = GroupSerializer(many=True,read_only = True)\n"
                },
                {
                    "date": 1739428764563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -122,9 +122,9 @@\n     def create(self, validated_data):\n         groups = validated_data.pop('groups', [])\n         print(groups,\"---------------------\")\n         social_media_data = validated_data.pop('social_media', [])\n-        password = validated_data.pop('password', None)\n+        # password = validated_data.pop('password', None)\n \n         # Create user\n         user = User.objects.create(**validated_data)\n         \n"
                },
                {
                    "date": 1739428771975,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -122,9 +122,9 @@\n     def create(self, validated_data):\n         groups = validated_data.pop('groups', [])\n         print(groups,\"---------------------\")\n         social_media_data = validated_data.pop('social_media', [])\n-        # password = validated_data.pop('password', None)\n+        password = validated_data.pop('password', None)\n \n         # Create user\n         user = User.objects.create(**validated_data)\n         \n"
                },
                {
                    "date": 1739429059094,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,8 +78,21 @@\n         ref_name = \"group\"\n         model = Permission\n         fields = ['id', 'name', 'codename']\n         \n+ Serializer for Colleges (Assuming User has a ForeignKey to College)\n+class CollegeSerializer(serializers.ModelSerializer):\n+    class Meta:\n+        model = College\n+        fields = ['id', 'name', 'location']  # Adjust based on model fields\n+\n+# Serializer for Social Media (Assuming it's a related field)\n+class SocialMediaSerializer(serializers.ModelSerializer):\n+    class Meta:\n+        model = SocialMedia\n+        fields = '__all__'  # Include all fields\n+\n+        \n class GroupSerializer(serializers.ModelSerializer):\n     # permissions = PermissionSerializer(many=True, read_only=True)\n     class Meta:\n         model = Group\n"
                },
                {
                    "date": 1739429070876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,38 +60,27 @@\n         # If parsing fails, wrap it in a list instead\n         mutable_data[value_to_convert] = [value_to_convert_data]\n         return mutable_data\n     \n-# class SocialMediaSerializer(serializers.ModelSerializer):\n-#     class Meta:\n-#         model = SocialMedia\n-#         fields = ['id','name', 'url', 'media', 'created_at', 'updated_at' ]  # Adjust fields as per your SocialMedia model\n+class SocialMediaSerializer(serializers.ModelSerializer):\n+    class Meta:\n+        model = SocialMedia\n+        fields = ['id','name', 'url', 'media', 'created_at', 'updated_at' ]  # Adjust fields as per your SocialMedia model\n \n-# class StaffSocialMediaSerializer(serializers.ModelSerializer):\n-#     social_media = SocialMediaSerializer(read_only=True)\n+class StaffSocialMediaSerializer(serializers.ModelSerializer):\n+    social_media = SocialMediaSerializer(read_only=True)\n \n-#     class Meta:\n-#         model = StaffHaveSocialMedia\n-#         fields = ['social_media', 'social_media_url','created_at', 'updated_at']\n+    class Meta:\n+        model = StaffHaveSocialMedia\n+        fields = ['social_media', 'social_media_url','created_at', 'updated_at']\n \n class PermissionSerializer(serializers.ModelSerializer):\n     class Meta:\n         ref_name = \"group\"\n         model = Permission\n         fields = ['id', 'name', 'codename']\n         \n- Serializer for Colleges (Assuming User has a ForeignKey to College)\n-class CollegeSerializer(serializers.ModelSerializer):\n-    class Meta:\n-        model = College\n-        fields = ['id', 'name', 'location']  # Adjust based on model fields\n \n-# Serializer for Social Media (Assuming it's a related field)\n-class SocialMediaSerializer(serializers.ModelSerializer):\n-    class Meta:\n-        model = SocialMedia\n-        fields = '__all__'  # Include all fields\n-\n         \n class GroupSerializer(serializers.ModelSerializer):\n     # permissions = PermissionSerializer(many=True, read_only=True)\n     class Meta:\n"
                },
                {
                    "date": 1739429077032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,19 +60,19 @@\n         # If parsing fails, wrap it in a list instead\n         mutable_data[value_to_convert] = [value_to_convert_data]\n         return mutable_data\n     \n-class SocialMediaSerializer(serializers.ModelSerializer):\n-    class Meta:\n-        model = SocialMedia\n-        fields = ['id','name', 'url', 'media', 'created_at', 'updated_at' ]  # Adjust fields as per your SocialMedia model\n+# class SocialMediaSerializer(serializers.ModelSerializer):\n+#     class Meta:\n+#         model = SocialMedia\n+#         fields = ['id','name', 'url', 'media', 'created_at', 'updated_at' ]  # Adjust fields as per your SocialMedia model\n \n-class StaffSocialMediaSerializer(serializers.ModelSerializer):\n-    social_media = SocialMediaSerializer(read_only=True)\n+# class StaffSocialMediaSerializer(serializers.ModelSerializer):\n+#     social_media = SocialMediaSerializer(read_only=True)\n \n-    class Meta:\n-        model = StaffHaveSocialMedia\n-        fields = ['social_media', 'social_media_url','created_at', 'updated_at']\n+#     class Meta:\n+#         model = StaffHaveSocialMedia\n+#         fields = ['social_media', 'social_media_url','created_at', 'updated_at']\n \n class PermissionSerializer(serializers.ModelSerializer):\n     class Meta:\n         ref_name = \"group\"\n"
                },
                {
                    "date": 1739429085912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n from django.contrib.auth import get_user_model\n # from department.models import Department\n from django.contrib.auth.models import Group, Permission\n from django.contrib.auth.hashers import check_password, make_password\n-# from socialmedia.models import SocialMedia,StaffHaveSocialMedia\n+from socialmedia.models import SocialMedia,\n from accounts.models import CustomUser as User\n import ast\n \n \n"
                },
                {
                    "date": 1739429097578,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n from django.contrib.auth import get_user_model\n # from department.models import Department\n from django.contrib.auth.models import Group, Permission\n from django.contrib.auth.hashers import check_password, make_password\n-from socialmedia.models import SocialMedia,\n+from socialmedia.models import SocialMedia\n from accounts.models import CustomUser as User\n import ast\n \n \n@@ -60,12 +60,12 @@\n         # If parsing fails, wrap it in a list instead\n         mutable_data[value_to_convert] = [value_to_convert_data]\n         return mutable_data\n     \n-# class SocialMediaSerializer(serializers.ModelSerializer):\n-#     class Meta:\n-#         model = SocialMedia\n-#         fields = ['id','name', 'url', 'media', 'created_at', 'updated_at' ]  # Adjust fields as per your SocialMedia model\n+class SocialMediaSerializer(serializers.ModelSerializer):\n+    class Meta:\n+        model = SocialMedia\n+        fields = ['id','name', 'url', 'media', 'created_at', 'updated_at' ]  # Adjust fields as per your SocialMedia model\n \n # class StaffSocialMediaSerializer(serializers.ModelSerializer):\n #     social_media = SocialMediaSerializer(read_only=True)\n \n"
                },
                {
                    "date": 1739429108310,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,9 +64,12 @@\n class SocialMediaSerializer(serializers.ModelSerializer):\n     class Meta:\n         model = SocialMedia\n         fields = ['id','name', 'url', 'media', 'created_at', 'updated_at' ]  # Adjust fields as per your SocialMedia model\n-\n+class CollegeSerializer(serializers.ModelSerializer):\n+    class Meta:\n+        model = College\n+        fields = ['id', 'name', 'location']  # Adjust based on model fields\n # class StaffSocialMediaSerializer(serializers.ModelSerializer):\n #     social_media = SocialMediaSerializer(read_only=True)\n \n #     class Meta:\n"
                },
                {
                    "date": 1739429115199,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,9 @@\n from django.contrib.auth.models import Group, Permission\n from django.contrib.auth.hashers import check_password, make_password\n from socialmedia.models import SocialMedia\n from accounts.models import CustomUser as User\n+from colle\n import ast\n \n \n # User = get_user_model()\n"
                },
                {
                    "date": 1739429120486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n from django.contrib.auth.models import Group, Permission\n from django.contrib.auth.hashers import check_password, make_password\n from socialmedia.models import SocialMedia\n from accounts.models import CustomUser as User\n-from colle\n+from collegemanagement.models import College\n import ast\n \n \n # User = get_user_model()\n"
                },
                {
                    "date": 1739429151890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,8 +113,10 @@\n     \n     def to_internal_value(self, data):\n         \"\"\"Convert groups input from string to list using str_to_list.\"\"\"\n         data = str_to_list(data, 'groups')  # Convert string to list for certification\n+        data = str_to_list(data, 'groups')  \n+        data = str_to_list(data, 'social_media') \n         return super().to_internal_value(data)\n     \n \n     class Meta:\n"
                },
                {
                    "date": 1739429161849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -112,9 +112,8 @@\n     # usersocial = StaffSocialMediaSerializer(many=True, required=False)\n     \n     def to_internal_value(self, data):\n         \"\"\"Convert groups input from string to list using str_to_list.\"\"\"\n-        data = str_to_list(data, 'groups')  # Convert string to list for certification\n         data = str_to_list(data, 'groups')  \n         data = str_to_list(data, 'social_media') \n         return super().to_internal_value(data)\n     \n"
                },
                {
                    "date": 1739429188804,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -127,9 +127,8 @@\n         \n \n     def create(self, validated_data):\n         groups = validated_data.pop('groups', [])\n-        print(groups,\"---------------------\")\n         social_media_data = validated_data.pop('social_media', [])\n         password = validated_data.pop('password', None)\n \n         # Create user\n@@ -137,14 +136,16 @@\n         \n         if password:\n             user.set_password(password)\n \n-        # Ensure groups only contain IDs\n-        if groups:\n-            print(groups,\"!!!!!!!!!!!!!!!!!!!!\")\n-            group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-            user.groups.set(group_ids)  \n+        # Assign groups\n+        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+        user.groups.set(group_ids)  \n \n+        # Assign social media (assuming it's ManyToMany)\n+        if social_media_data:\n+            user.social_media.set(social_media_data)\n+\n         user.save()\n         return user\n \n     def update(self, instance, validated_data):\n@@ -160,14 +161,28 @@\n             instance.set_password(password)\n \n         # Convert groups into primary keys if they are objects\n         group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+        instance.groups.set(group_ids)\n \n-        instance.groups.set(group_ids)  # ✅ Ensure only IDs are passed\n+        # Assign social media (if present)\n+        if social_media_data:\n+            instance.social_media.set(social_media_data)\n+\n         instance.save()\n-\n         return instance\n \n+    def to_representation(self, instance):\n+        \"\"\"Customize response to include detailed foreign key objects instead of just IDs.\"\"\"\n+        data = super().to_representation(instance)\n+\n+        # Include nested representations\n+        data['groups'] = GroupSerializer(instance.groups.all(), many=True).data\n+        data['college'] = CollegeSerializer(instance.college).data if instance.college else None\n+        data['social_media'] = SocialMediaSerializer(instance.social_media.all(), many=True).data\n+        \n+        return data\n+\n class CustomUserRetrieveSerializer(serializers.ModelSerializer):\n     # usersocial = StaffSocialMediaSerializer(many=True,read_only = True)\n     groups = GroupSerializer(many=True,read_only = True)\n     # department = DepartmentSerializer(read_only = True)\n"
                },
                {
                    "date": 1739862045276,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,28 +126,29 @@\n         }\n         \n \n     def create(self, validated_data):\n-        groups = validated_data.pop('groups', [])\n-        social_media_data = validated_data.pop('social_media', [])\n-        password = validated_data.pop('password', None)\n+    # Extract groups and social media data\n+    groups = [value for key, value in validated_data.items() if key.startswith('groups[')]\n+    social_media_data = validated_data.pop('social_media', [])\n+    password = validated_data.pop('password', None)\n \n-        # Create user\n-        user = User.objects.create(**validated_data)\n-        \n-        if password:\n-            user.set_password(password)\n+    # Create user\n+    user = User.objects.create(**validated_data)\n+    \n+    if password:\n+        user.set_password(password)\n \n-        # Assign groups\n-        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-        user.groups.set(group_ids)  \n+    # Assign groups\n+    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+    user.groups.set(group_ids)  \n \n-        # Assign social media (assuming it's ManyToMany)\n-        if social_media_data:\n-            user.social_media.set(social_media_data)\n+    # Assign social media (assuming it's ManyToMany)\n+    if social_media_data:\n+        user.social_media.set(social_media_data)\n \n-        user.save()\n-        return user\n+    user.save()\n+    return user\n \n     def update(self, instance, validated_data):\n         groups = validated_data.pop('groups', [])\n         social_media_data = validated_data.pop('social_media', [])\n"
                },
                {
                    "date": 1739862059925,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,53 +126,54 @@\n         }\n         \n \n     def create(self, validated_data):\n+        # Extract groups and social media data\n+        groups = [value for key, value in validated_data.items() if key.startswith('groups[')]\n+        social_media_data = validated_data.pop('social_media', [])\n+        password = validated_data.pop('password', None)\n+\n+        # Create user\n+        user = User.objects.create(**validated_data)\n+        \n+        if password:\n+            user.set_password(password)\n+\n+        # Assign groups\n+        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+        user.groups.set(group_ids)  \n+\n+        # Assign social media (assuming it's ManyToMany)\n+        if social_media_data:\n+            user.social_media.set(social_media_data)\n+\n+        user.save()\n+        return user\n+\n+    def update(self, instance, validated_data):\n     # Extract groups and social media data\n     groups = [value for key, value in validated_data.items() if key.startswith('groups[')]\n     social_media_data = validated_data.pop('social_media', [])\n     password = validated_data.pop('password', None)\n \n-    # Create user\n-    user = User.objects.create(**validated_data)\n-    \n+    # Update user fields\n+    for attr, value in validated_data.items():\n+        setattr(instance, attr, value)\n+\n     if password:\n-        user.set_password(password)\n+        instance.set_password(password)\n \n-    # Assign groups\n+    # Convert groups into primary keys if they are objects\n     group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-    user.groups.set(group_ids)  \n+    instance.groups.set(group_ids)\n \n-    # Assign social media (assuming it's ManyToMany)\n+    # Assign social media (if present)\n     if social_media_data:\n-        user.social_media.set(social_media_data)\n+        instance.social_media.set(social_media_data)\n \n-    user.save()\n-    return user\n+    instance.save()\n+    return instance\n \n-    def update(self, instance, validated_data):\n-        groups = validated_data.pop('groups', [])\n-        social_media_data = validated_data.pop('social_media', [])\n-        password = validated_data.pop('password', None)\n-\n-        # Update user fields\n-        for attr, value in validated_data.items():\n-            setattr(instance, attr, value)\n-\n-        if password:\n-            instance.set_password(password)\n-\n-        # Convert groups into primary keys if they are objects\n-        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-        instance.groups.set(group_ids)\n-\n-        # Assign social media (if present)\n-        if social_media_data:\n-            instance.social_media.set(social_media_data)\n-\n-        instance.save()\n-        return instance\n-\n     def to_representation(self, instance):\n         \"\"\"Customize response to include detailed foreign key objects instead of just IDs.\"\"\"\n         data = super().to_representation(instance)\n \n"
                },
                {
                    "date": 1739862065065,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -149,30 +149,30 @@\n         user.save()\n         return user\n \n     def update(self, instance, validated_data):\n-    # Extract groups and social media data\n-    groups = [value for key, value in validated_data.items() if key.startswith('groups[')]\n-    social_media_data = validated_data.pop('social_media', [])\n-    password = validated_data.pop('password', None)\n+        # Extract groups and social media data\n+        groups = [value for key, value in validated_data.items() if key.startswith('groups[')]\n+        social_media_data = validated_data.pop('social_media', [])\n+        password = validated_data.pop('password', None)\n \n-    # Update user fields\n-    for attr, value in validated_data.items():\n-        setattr(instance, attr, value)\n+        # Update user fields\n+        for attr, value in validated_data.items():\n+            setattr(instance, attr, value)\n \n-    if password:\n-        instance.set_password(password)\n+        if password:\n+            instance.set_password(password)\n \n-    # Convert groups into primary keys if they are objects\n-    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-    instance.groups.set(group_ids)\n+        # Convert groups into primary keys if they are objects\n+        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+        instance.groups.set(group_ids)\n \n-    # Assign social media (if present)\n-    if social_media_data:\n-        instance.social_media.set(social_media_data)\n+        # Assign social media (if present)\n+        if social_media_data:\n+            instance.social_media.set(social_media_data)\n \n-    instance.save()\n-    return instance\n+        instance.save()\n+        return instance\n \n     def to_representation(self, instance):\n         \"\"\"Customize response to include detailed foreign key objects instead of just IDs.\"\"\"\n         data = super().to_representation(instance)\n"
                },
                {
                    "date": 1739862136786,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,31 +125,38 @@\n             'password': {'write_only': True}\n         }\n         \n \n-    def create(self, validated_data):\n-        # Extract groups and social media data\n-        groups = [value for key, value in validated_data.items() if key.startswith('groups[')]\n-        social_media_data = validated_data.pop('social_media', [])\n-        password = validated_data.pop('password', None)\n+    def create(self, request, *args, **kwargs):\n+    # Extract data from the request\n+    data = request.data\n \n-        # Create user\n-        user = User.objects.create(**validated_data)\n-        \n-        if password:\n-            user.set_password(password)\n+    # Extract groups and social media data\n+    groups = [value for key, value in data.items() if key.startswith('groups[')]\n+    social_media_data = data.get('social_media', [])\n+    password = data.get('password', None)\n \n-        # Assign groups\n-        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-        user.groups.set(group_ids)  \n+    # Create user\n+    user = User.objects.create(\n+        username=data.get('username'),\n+        email=data.get('email'),\n+        # Add other fields as needed\n+    )\n+    \n+    if password:\n+        user.set_password(password)\n \n-        # Assign social media (assuming it's ManyToMany)\n-        if social_media_data:\n-            user.social_media.set(social_media_data)\n+    # Assign groups\n+    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+    user.groups.set(group_ids)  \n \n-        user.save()\n-        return user\n+    # Assign social media (assuming it's ManyToMany)\n+    if social_media_data:\n+        user.social_media.set(social_media_data)\n \n+    user.save()\n+    return user\n+\n     def update(self, instance, validated_data):\n         # Extract groups and social media data\n         groups = [value for key, value in validated_data.items() if key.startswith('groups[')]\n         social_media_data = validated_data.pop('social_media', [])\n"
                },
                {
                    "date": 1739862142879,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,36 +126,36 @@\n         }\n         \n \n     def create(self, request, *args, **kwargs):\n-    # Extract data from the request\n-    data = request.data\n+        # Extract data from the request\n+        data = request.data\n \n-    # Extract groups and social media data\n-    groups = [value for key, value in data.items() if key.startswith('groups[')]\n-    social_media_data = data.get('social_media', [])\n-    password = data.get('password', None)\n+        # Extract groups and social media data\n+        groups = [value for key, value in data.items() if key.startswith('groups[')]\n+        social_media_data = data.get('social_media', [])\n+        password = data.get('password', None)\n \n-    # Create user\n-    user = User.objects.create(\n-        username=data.get('username'),\n-        email=data.get('email'),\n-        # Add other fields as needed\n-    )\n-    \n-    if password:\n-        user.set_password(password)\n+        # Create user\n+        user = User.objects.create(\n+            username=data.get('username'),\n+            email=data.get('email'),\n+            # Add other fields as needed\n+        )\n+        \n+        if password:\n+            user.set_password(password)\n \n-    # Assign groups\n-    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-    user.groups.set(group_ids)  \n+        # Assign groups\n+        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+        user.groups.set(group_ids)  \n \n-    # Assign social media (assuming it's ManyToMany)\n-    if social_media_data:\n-        user.social_media.set(social_media_data)\n+        # Assign social media (assuming it's ManyToMany)\n+        if social_media_data:\n+            user.social_media.set(social_media_data)\n \n-    user.save()\n-    return user\n+        user.save()\n+        return user\n \n     def update(self, instance, validated_data):\n         # Extract groups and social media data\n         groups = [value for key, value in validated_data.items() if key.startswith('groups[')]\n"
                },
                {
                    "date": 1739862153008,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -155,31 +155,38 @@\n \n         user.save()\n         return user\n \n-    def update(self, instance, validated_data):\n-        # Extract groups and social media data\n-        groups = [value for key, value in validated_data.items() if key.startswith('groups[')]\n-        social_media_data = validated_data.pop('social_media', [])\n-        password = validated_data.pop('password', None)\n+    def update(self, request, *args, **kwargs):\n+    # Extract data from the request\n+    data = request.data\n \n-        # Update user fields\n-        for attr, value in validated_data.items():\n+    # Get the user instance to update\n+    instance = self.get_object()\n+\n+    # Extract groups and social media data\n+    groups = [value for key, value in data.items() if key.startswith('groups[')]\n+    social_media_data = data.get('social_media', [])\n+    password = data.get('password', None)\n+\n+    # Update user fields\n+    for attr, value in data.items():\n+        if attr not in ['groups', 'social_media', 'password']:  # Skip special fields\n             setattr(instance, attr, value)\n \n-        if password:\n-            instance.set_password(password)\n+    if password:\n+        instance.set_password(password)\n \n-        # Convert groups into primary keys if they are objects\n-        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-        instance.groups.set(group_ids)\n+    # Convert groups into primary keys if they are objects\n+    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+    instance.groups.set(group_ids)\n \n-        # Assign social media (if present)\n-        if social_media_data:\n-            instance.social_media.set(social_media_data)\n+    # Assign social media (if present)\n+    if social_media_data:\n+        instance.social_media.set(social_media_data)\n \n-        instance.save()\n-        return instance\n+    instance.save()\n+    return instance\n \n     def to_representation(self, instance):\n         \"\"\"Customize response to include detailed foreign key objects instead of just IDs.\"\"\"\n         data = super().to_representation(instance)\n"
                },
                {
                    "date": 1739862158356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,37 +156,37 @@\n         user.save()\n         return user\n \n     def update(self, request, *args, **kwargs):\n-    # Extract data from the request\n-    data = request.data\n+        # Extract data from the request\n+        data = request.data\n \n-    # Get the user instance to update\n-    instance = self.get_object()\n+        # Get the user instance to update\n+        instance = self.get_object()\n \n-    # Extract groups and social media data\n-    groups = [value for key, value in data.items() if key.startswith('groups[')]\n-    social_media_data = data.get('social_media', [])\n-    password = data.get('password', None)\n+        # Extract groups and social media data\n+        groups = [value for key, value in data.items() if key.startswith('groups[')]\n+        social_media_data = data.get('social_media', [])\n+        password = data.get('password', None)\n \n-    # Update user fields\n-    for attr, value in data.items():\n-        if attr not in ['groups', 'social_media', 'password']:  # Skip special fields\n-            setattr(instance, attr, value)\n+        # Update user fields\n+        for attr, value in data.items():\n+            if attr not in ['groups', 'social_media', 'password']:  # Skip special fields\n+                setattr(instance, attr, value)\n \n-    if password:\n-        instance.set_password(password)\n+        if password:\n+            instance.set_password(password)\n \n-    # Convert groups into primary keys if they are objects\n-    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-    instance.groups.set(group_ids)\n+        # Convert groups into primary keys if they are objects\n+        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+        instance.groups.set(group_ids)\n \n-    # Assign social media (if present)\n-    if social_media_data:\n-        instance.social_media.set(social_media_data)\n+        # Assign social media (if present)\n+        if social_media_data:\n+            instance.social_media.set(social_media_data)\n \n-    instance.save()\n-    return instance\n+        instance.save()\n+        return instance\n \n     def to_representation(self, instance):\n         \"\"\"Customize response to include detailed foreign key objects instead of just IDs.\"\"\"\n         data = super().to_representation(instance)\n"
                },
                {
                    "date": 1739862324207,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,68 +126,81 @@\n         }\n         \n \n     def create(self, request, *args, **kwargs):\n-        # Extract data from the request\n-        data = request.data\n+    # Extract data from the request\n+    data = request.data\n \n-        # Extract groups and social media data\n-        groups = [value for key, value in data.items() if key.startswith('groups[')]\n-        social_media_data = data.get('social_media', [])\n-        password = data.get('password', None)\n+    # Extract groups and social media data (both as individual keys)\n+    groups = [value for key, value in data.items() if key.startswith('groups[')]\n+    social_media = [value for key, value in data.items() if key.startswith('social_media[')]\n \n-        # Create user\n-        user = User.objects.create(\n-            username=data.get('username'),\n-            email=data.get('email'),\n-            # Add other fields as needed\n-        )\n-        \n-        if password:\n-            user.set_password(password)\n+    # If social_media wasn't provided as separate keys, try the list/dict provided directly\n+    if not social_media:\n+        social_media = data.get('social_media', [])\n \n-        # Assign groups\n-        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-        user.groups.set(group_ids)  \n+    password = data.get('password', None)\n \n-        # Assign social media (assuming it's ManyToMany)\n-        if social_media_data:\n-            user.social_media.set(social_media_data)\n+    # Create user\n+    user = User.objects.create(\n+        username=data.get('username'),\n+        email=data.get('email'),\n+        # Add other fields as needed\n+    )\n+    \n+    if password:\n+        user.set_password(password)\n \n-        user.save()\n-        return user\n+    # Assign groups: Convert to primary keys if necessary\n+    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+    user.groups.set(group_ids)  \n \n-    def update(self, request, *args, **kwargs):\n-        # Extract data from the request\n-        data = request.data\n+    # Assign social media: Convert to primary keys if necessary\n+    social_media_ids = [sm.id if hasattr(sm, 'id') else sm for sm in social_media]\n+    if social_media_ids:\n+        user.social_media.set(social_media_ids)\n \n-        # Get the user instance to update\n-        instance = self.get_object()\n+    user.save()\n+    return user\n \n-        # Extract groups and social media data\n-        groups = [value for key, value in data.items() if key.startswith('groups[')]\n-        social_media_data = data.get('social_media', [])\n-        password = data.get('password', None)\n+def update(self, request, *args, **kwargs):\n+    # Extract data from the request\n+    data = request.data\n \n-        # Update user fields\n-        for attr, value in data.items():\n-            if attr not in ['groups', 'social_media', 'password']:  # Skip special fields\n-                setattr(instance, attr, value)\n+    # Get the user instance to update\n+    instance = self.get_object()\n \n-        if password:\n-            instance.set_password(password)\n+    # Extract groups and social media data (both as individual keys)\n+    groups = [value for key, value in data.items() if key.startswith('groups[')]\n+    social_media = [value for key, value in data.items() if key.startswith('social_media[')]\n+    \n+    # If social_media wasn't provided as separate keys, try the list/dict provided directly\n+    if not social_media:\n+        social_media = data.get('social_media', [])\n+    \n+    password = data.get('password', None)\n \n-        # Convert groups into primary keys if they are objects\n-        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-        instance.groups.set(group_ids)\n+    # Update user fields (skip special fields)\n+    for attr, value in data.items():\n+        if attr not in ['groups', 'social_media', 'password']:\n+            setattr(instance, attr, value)\n \n-        # Assign social media (if present)\n-        if social_media_data:\n-            instance.social_media.set(social_media_data)\n+    if password:\n+        instance.set_password(password)\n \n-        instance.save()\n-        return instance\n+    # Update groups: Convert to primary keys if necessary\n+    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+    instance.groups.set(group_ids)\n \n+    # Update social media: Convert to primary keys if necessary\n+    social_media_ids = [sm.id if hasattr(sm, 'id') else sm for sm in social_media]\n+    if social_media_ids:\n+        instance.social_media.set(social_media_ids)\n+\n+    instance.save()\n+    return instance\n+\n+\n     def to_representation(self, instance):\n         \"\"\"Customize response to include detailed foreign key objects instead of just IDs.\"\"\"\n         data = super().to_representation(instance)\n \n"
                },
                {
                    "date": 1739862330046,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,79 +126,79 @@\n         }\n         \n \n     def create(self, request, *args, **kwargs):\n-    # Extract data from the request\n-    data = request.data\n+        # Extract data from the request\n+        data = request.data\n \n-    # Extract groups and social media data (both as individual keys)\n-    groups = [value for key, value in data.items() if key.startswith('groups[')]\n-    social_media = [value for key, value in data.items() if key.startswith('social_media[')]\n+        # Extract groups and social media data (both as individual keys)\n+        groups = [value for key, value in data.items() if key.startswith('groups[')]\n+        social_media = [value for key, value in data.items() if key.startswith('social_media[')]\n \n-    # If social_media wasn't provided as separate keys, try the list/dict provided directly\n-    if not social_media:\n-        social_media = data.get('social_media', [])\n+        # If social_media wasn't provided as separate keys, try the list/dict provided directly\n+        if not social_media:\n+            social_media = data.get('social_media', [])\n \n-    password = data.get('password', None)\n+        password = data.get('password', None)\n \n-    # Create user\n-    user = User.objects.create(\n-        username=data.get('username'),\n-        email=data.get('email'),\n-        # Add other fields as needed\n-    )\n-    \n-    if password:\n-        user.set_password(password)\n+        # Create user\n+        user = User.objects.create(\n+            username=data.get('username'),\n+            email=data.get('email'),\n+            # Add other fields as needed\n+        )\n+        \n+        if password:\n+            user.set_password(password)\n \n-    # Assign groups: Convert to primary keys if necessary\n-    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-    user.groups.set(group_ids)  \n+        # Assign groups: Convert to primary keys if necessary\n+        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+        user.groups.set(group_ids)  \n \n-    # Assign social media: Convert to primary keys if necessary\n-    social_media_ids = [sm.id if hasattr(sm, 'id') else sm for sm in social_media]\n-    if social_media_ids:\n-        user.social_media.set(social_media_ids)\n+        # Assign social media: Convert to primary keys if necessary\n+        social_media_ids = [sm.id if hasattr(sm, 'id') else sm for sm in social_media]\n+        if social_media_ids:\n+            user.social_media.set(social_media_ids)\n \n-    user.save()\n-    return user\n+        user.save()\n+        return user\n \n-def update(self, request, *args, **kwargs):\n-    # Extract data from the request\n-    data = request.data\n+    def update(self, request, *args, **kwargs):\n+        # Extract data from the request\n+        data = request.data\n \n-    # Get the user instance to update\n-    instance = self.get_object()\n+        # Get the user instance to update\n+        instance = self.get_object()\n \n-    # Extract groups and social media data (both as individual keys)\n-    groups = [value for key, value in data.items() if key.startswith('groups[')]\n-    social_media = [value for key, value in data.items() if key.startswith('social_media[')]\n-    \n-    # If social_media wasn't provided as separate keys, try the list/dict provided directly\n-    if not social_media:\n-        social_media = data.get('social_media', [])\n-    \n-    password = data.get('password', None)\n+        # Extract groups and social media data (both as individual keys)\n+        groups = [value for key, value in data.items() if key.startswith('groups[')]\n+        social_media = [value for key, value in data.items() if key.startswith('social_media[')]\n+        \n+        # If social_media wasn't provided as separate keys, try the list/dict provided directly\n+        if not social_media:\n+            social_media = data.get('social_media', [])\n+        \n+        password = data.get('password', None)\n \n-    # Update user fields (skip special fields)\n-    for attr, value in data.items():\n-        if attr not in ['groups', 'social_media', 'password']:\n-            setattr(instance, attr, value)\n+        # Update user fields (skip special fields)\n+        for attr, value in data.items():\n+            if attr not in ['groups', 'social_media', 'password']:\n+                setattr(instance, attr, value)\n \n-    if password:\n-        instance.set_password(password)\n+        if password:\n+            instance.set_password(password)\n \n-    # Update groups: Convert to primary keys if necessary\n-    group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n-    instance.groups.set(group_ids)\n+        # Update groups: Convert to primary keys if necessary\n+        group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n+        instance.groups.set(group_ids)\n \n-    # Update social media: Convert to primary keys if necessary\n-    social_media_ids = [sm.id if hasattr(sm, 'id') else sm for sm in social_media]\n-    if social_media_ids:\n-        instance.social_media.set(social_media_ids)\n+        # Update social media: Convert to primary keys if necessary\n+        social_media_ids = [sm.id if hasattr(sm, 'id') else sm for sm in social_media]\n+        if social_media_ids:\n+            instance.social_media.set(social_media_ids)\n \n-    instance.save()\n-    return instance\n+        instance.save()\n+        return instance\n \n \n     def to_representation(self, instance):\n         \"\"\"Customize response to include detailed foreign key objects instead of just IDs.\"\"\"\n"
                },
                {
                    "date": 1739863368063,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,82 +125,53 @@\n             'password': {'write_only': True}\n         }\n         \n \n-    def create(self, request, *args, **kwargs):\n-        # Extract data from the request\n-        data = request.data\n+    def create(self, validated_data):\n+        groups = validated_data.pop('groups', [])\n+        social_media_data = validated_data.pop('social_media', [])\n+        password = validated_data.pop('password', None)\n \n-        # Extract groups and social media data (both as individual keys)\n-        groups = [value for key, value in data.items() if key.startswith('groups[')]\n-        social_media = [value for key, value in data.items() if key.startswith('social_media[')]\n-\n-        # If social_media wasn't provided as separate keys, try the list/dict provided directly\n-        if not social_media:\n-            social_media = data.get('social_media', [])\n-\n-        password = data.get('password', None)\n-\n         # Create user\n-        user = User.objects.create(\n-            username=data.get('username'),\n-            email=data.get('email'),\n-            # Add other fields as needed\n-        )\n+        user = User.objects.create(**validated_data)\n         \n         if password:\n             user.set_password(password)\n \n-        # Assign groups: Convert to primary keys if necessary\n+        # Assign groups\n         group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n         user.groups.set(group_ids)  \n \n-        # Assign social media: Convert to primary keys if necessary\n-        social_media_ids = [sm.id if hasattr(sm, 'id') else sm for sm in social_media]\n-        if social_media_ids:\n-            user.social_media.set(social_media_ids)\n+        # Assign social media (assuming it's ManyToMany)\n+        if social_media_data:\n+            user.social_media.set(social_media_data)\n \n         user.save()\n         return user\n \n-    def update(self, request, *args, **kwargs):\n-        # Extract data from the request\n-        data = request.data\n+    def update(self, instance, validated_data):\n+        groups = validated_data.pop('groups', [])\n+        social_media_data = validated_data.pop('social_media', [])\n+        password = validated_data.pop('password', None)\n \n-        # Get the user instance to update\n-        instance = self.get_object()\n+        # Update user fields\n+        for attr, value in validated_data.items():\n+            setattr(instance, attr, value)\n \n-        # Extract groups and social media data (both as individual keys)\n-        groups = [value for key, value in data.items() if key.startswith('groups[')]\n-        social_media = [value for key, value in data.items() if key.startswith('social_media[')]\n-        \n-        # If social_media wasn't provided as separate keys, try the list/dict provided directly\n-        if not social_media:\n-            social_media = data.get('social_media', [])\n-        \n-        password = data.get('password', None)\n-\n-        # Update user fields (skip special fields)\n-        for attr, value in data.items():\n-            if attr not in ['groups', 'social_media', 'password']:\n-                setattr(instance, attr, value)\n-\n         if password:\n             instance.set_password(password)\n \n-        # Update groups: Convert to primary keys if necessary\n+        # Convert groups into primary keys if they are objects\n         group_ids = [group.id if hasattr(group, 'id') else group for group in groups]\n         instance.groups.set(group_ids)\n \n-        # Update social media: Convert to primary keys if necessary\n-        social_media_ids = [sm.id if hasattr(sm, 'id') else sm for sm in social_media]\n-        if social_media_ids:\n-            instance.social_media.set(social_media_ids)\n+        # Assign social media (if present)\n+        if social_media_data:\n+            instance.social_media.set(social_media_data)\n \n         instance.save()\n         return instance\n \n-\n     def to_representation(self, instance):\n         \"\"\"Customize response to include detailed foreign key objects instead of just IDs.\"\"\"\n         data = super().to_representation(instance)\n \n"
                },
                {
                    "date": 1739892559822,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,9 +68,9 @@\n         fields = ['id','name', 'url', 'media', 'created_at', 'updated_at' ]  # Adjust fields as per your SocialMedia model\n class CollegeSerializer(serializers.ModelSerializer):\n     class Meta:\n         model = College\n-        fields = ['id', 'name', 'location']  # Adjust based on model fields\n+        fields = ['id', 'name', 'address']  # Adjust based on model fields\n # class StaffSocialMediaSerializer(serializers.ModelSerializer):\n #     social_media = SocialMediaSerializer(read_only=True)\n \n #     class Meta:\n"
                }
            ],
            "date": 1728378543651,
            "name": "Commit-0",
            "content": "from rest_framework import serializers\nfrom django.contrib.auth.models import Group,Permission\nfrom ..models import CustomUser\nfrom django.contrib.auth.hashers import make_password\nfrom ...accountsmanagement import roles\nfrom ..utilities.permission import SecureFields\n\nclass CustomUserReadSerializer(serializers.ModelSerializer):\n    class Meta:\n        ref_name =  \"account serializers\"\n        model = CustomUser\n        # fields = '__all__' \n        exclude = ['password']\n\nclass CustomUserReadLimitedSerializer(serializers.ModelSerializer):\n    class Meta:\n        ref_name =  \"CustomUserReadLimitedSerializer serializers\"\n        model = CustomUser\n        fields = ['id','email','first_name','username',] \n\nclass CustomUserReadLimitedSerializer_1(serializers.ModelSerializer):\n    class Meta:\n        ref_name =  \"CustomUserReadLimitedSerializer serializers\"\n        model = CustomUser\n        fields = ['id','email','first_name','username','last_name','role','getRoleName']\n\n\nclass CustomUserSerializer(serializers.ModelSerializer):\n    \n    def validate_password(self,value):#field level validation\n        if len(value) < 5:\n            raise serializers.ValidationError('Password must be 8 digit')\n        return make_password(value) \n    \n    def validate_role(self,value):#field level validation\n        user = self.context['request'].user\n        # print(user.is_authenticated)\n        if not user.is_authenticated:\n            if value == roles.USER:\n                pass\n            else:\n                raise serializers.ValidationError(\"You can only set USER,PUBLISHER as role\") \n        elif user.role in [roles.ADMIN,roles.SUPER_ADMIN]:\n            return value\n        elif user.is_authenticated and value!=roles.USER:\n                raise serializers.ValidationError(\"You can only set USER as role\") \n        return value\n    \n    def validate_is_verified(self,value):\n\n        user = self.context['request'].user\n        if user.is_authenticated:\n            if user.role == roles.ADMIN:\n                return value\n            else:\n                return False\n        else:\n            return False\n\n    def validate_is_superuser(self,value):\n        if value == True:\n            raise serializers.ValidationError(\"You can not set USER as SYSTEM_ADMIN\") \n        else:\n            return False\n\n    def validate(self, attrs):\n        request = self.context.get('request')\n        action = self.context['view'].action     \n\n        if action == 'partial_update':\n            old_password = request.data.get('old_password')  \n            if old_password is not None:      \n                instance = self.instance\n                if not instance.check_password(old_password):\n                    raise serializers.ValidationError(\"Password does not match\")\n            attrs['old_password_change_case'] = True\n        return attrs        \n\n    def get_extra_kwargs(self):\n        extra_kwargs = super().get_extra_kwargs()\n        try:\n            if self.context['request'].method == 'PUT':\n                extra_kwargs['password'] = {'required': False}\n            return extra_kwargs\n        except:\n            pass\n    \n    class Meta:\n        ref_name =  \"accountWriteserializer\"\n        model = CustomUser\n        fields = '__all__' \n\n\n    def get_fields(self):\n        model_fields = super().get_fields()\n        SecureFields(self,model_fields,['email','is_active','is_verified','role','provider','username','is_superuser'],['PATCH','PUT'],[roles.ADMIN,roles.SUPER_ADMIN])\n        # SecureFields(self,model_fields,['provider'],['PATCH','PUT'],[]) #if empty [] it means it is striction for all\n        return model_fields\n\nclass RoleSerializer(serializers.Serializer):\n    role_id = serializers.IntegerField()\n    role_name = serializers.CharField()\n    def to_representation(self, instance):\n        return {'role_id': instance[0], 'role_name': instance[1]}\n\n\nclass GroupSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Group\n        fields = '__all__'  \n\nclass PermissionSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Permission\n        fields = '__all__'  \n\nclass LoginSerializer(serializers.Serializer):\n    email = serializers.EmailField()\n    username = serializers.CharField()\n    password = serializers.CharField()\n\nclass GroupNamesSerializer(serializers.Serializer):\n    group_names = serializers.ListField(child=serializers.CharField())\n\nclass PermissionGroupSerializer(serializers.Serializer):\n    permission_id = serializers.IntegerField()\n    groups = serializers.DictField(child=serializers.BooleanField())\n\n\nclass UserDetailsSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = CustomUser\n        fields = ['id', 'full_name', 'phone', 'image', 'email']\n    \n  \n    "
        }
    ]
}