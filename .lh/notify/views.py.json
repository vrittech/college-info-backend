{
    "sourceFile": "notify/views.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 26,
            "patches": [
                {
                    "date": 1739869347719,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739869355671,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n from rest_framework.response import Response\n from rest_framework.permissions import IsAuthenticated\n from .models import Notification\n from .serializers import NotificationSerializer\n-from .permissions import DynamicModelPermission\n+from ..permissions import DynamicModelPermission\n \n class NotificationViewSet(viewsets.ModelViewSet):\n     \"\"\"\n     API for managing notifications.\n"
                },
                {
                    "date": 1739869362572,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n from rest_framework.response import Response\n from rest_framework.permissions import IsAuthenticated\n from .models import Notification\n from .serializers import NotificationSerializer\n-from ..permissions import DynamicModelPermission\n+from mainproj.permissions import DynamicModelPermission\n \n class NotificationViewSet(viewsets.ModelViewSet):\n     \"\"\"\n     API for managing notifications.\n"
                },
                {
                    "date": 1739869736001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,31 +2,28 @@\n from rest_framework.response import Response\n from rest_framework.permissions import IsAuthenticated\n from .models import Notification\n from .serializers import NotificationSerializer\n-from mainproj.permissions import DynamicModelPermission\n+from .permissions import DynamicModelPermission\n \n class NotificationViewSet(viewsets.ModelViewSet):\n     \"\"\"\n     API for managing notifications.\n-    - Users can only see their own notifications.\n-    - Superusers can see all notifications.\n-    - Users can mark notifications as read.\n     \"\"\"\n     serializer_class = NotificationSerializer\n     permission_classes = [IsAuthenticated, DynamicModelPermission]\n \n     def get_queryset(self):\n         \"\"\"\n-        Fetch only notifications related to the user.\n+        Users only see notifications related to their actions.\n         \"\"\"\n         if self.request.user.is_superuser:\n             return Notification.objects.all().order_by(\"-created_at\")\n         return Notification.objects.filter(user=self.request.user).order_by(\"-created_at\")\n \n     def update(self, request, *args, **kwargs):\n         \"\"\"\n-        Mark a notification as read.\n+        Allow users to mark notifications as read.\n         \"\"\"\n         instance = self.get_object()\n         if instance.user != request.user:\n             return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n"
                },
                {
                    "date": 1739869741526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n from rest_framework.response import Response\n from rest_framework.permissions import IsAuthenticated\n from .models import Notification\n from .serializers import NotificationSerializer\n-from .permissions import DynamicModelPermission\n+from main.permissions import DynamicModelPermission\n \n class NotificationViewSet(viewsets.ModelViewSet):\n     \"\"\"\n     API for managing notifications.\n"
                },
                {
                    "date": 1739870603394,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,31 +2,26 @@\n from rest_framework.response import Response\n from rest_framework.permissions import IsAuthenticated\n from .models import Notification\n from .serializers import NotificationSerializer\n-from main.permissions import DynamicModelPermission\n \n class NotificationViewSet(viewsets.ModelViewSet):\n     \"\"\"\n     API for managing notifications.\n+    - Users only see their own notifications.\n+    - Superusers can see all notifications.\n     \"\"\"\n     serializer_class = NotificationSerializer\n-    permission_classes = [IsAuthenticated, DynamicModelPermission]\n+    permission_classes = [IsAuthenticated]\n \n     def get_queryset(self):\n-        \"\"\"\n-        Users only see notifications related to their actions.\n-        \"\"\"\n         if self.request.user.is_superuser:\n-            return Notification.objects.all().order_by(\"-created_at\")\n-        return Notification.objects.filter(user=self.request.user).order_by(\"-created_at\")\n+            return Notification.objects.all().order_by(\"-timestamp\")\n+        return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n \n     def update(self, request, *args, **kwargs):\n-        \"\"\"\n-        Allow users to mark notifications as read.\n-        \"\"\"\n         instance = self.get_object()\n-        if instance.user != request.user:\n+        if request.user != instance.user:\n             return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n \n         instance.is_read = True\n         instance.save()\n"
                },
                {
                    "date": 1740121020520,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,28 +1,28 @@\n-from rest_framework import viewsets, status\n-from rest_framework.response import Response\n-from rest_framework.permissions import IsAuthenticated\n-from .models import Notification\n-from .serializers import NotificationSerializer\n+# from rest_framework import viewsets, status\n+# from rest_framework.response import Response\n+# from rest_framework.permissions import IsAuthenticated\n+# from .models import Notification\n+# from .serializers import NotificationSerializer\n \n-class NotificationViewSet(viewsets.ModelViewSet):\n-    \"\"\"\n-    API for managing notifications.\n-    - Users only see their own notifications.\n-    - Superusers can see all notifications.\n-    \"\"\"\n-    serializer_class = NotificationSerializer\n-    permission_classes = [IsAuthenticated]\n+# class NotificationViewSet(viewsets.ModelViewSet):\n+#     \"\"\"\n+#     API for managing notifications.\n+#     - Users only see their own notifications.\n+#     - Superusers can see all notifications.\n+#     \"\"\"\n+#     serializer_class = NotificationSerializer\n+#     permission_classes = [IsAuthenticated]\n \n-    def get_queryset(self):\n-        if self.request.user.is_superuser:\n-            return Notification.objects.all().order_by(\"-timestamp\")\n-        return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n+#     def get_queryset(self):\n+#         if self.request.user.is_superuser:\n+#             return Notification.objects.all().order_by(\"-timestamp\")\n+#         return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n \n-    def update(self, request, *args, **kwargs):\n-        instance = self.get_object()\n-        if request.user != instance.user:\n-            return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n+#     def update(self, request, *args, **kwargs):\n+#         instance = self.get_object()\n+#         if request.user != instance.user:\n+#             return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n \n-        instance.is_read = True\n-        instance.save()\n-        return Response({\"message\": \"Notification marked as read\"}, status=status.HTTP_200_OK)\n+#         instance.is_read = True\n+#         instance.save()\n+#         return Response({\"message\": \"Notification marked as read\"}, status=status.HTTP_200_OK)\n"
                },
                {
                    "date": 1740121026245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,28 +1,28 @@\n-# from rest_framework import viewsets, status\n-# from rest_framework.response import Response\n-# from rest_framework.permissions import IsAuthenticated\n-# from .models import Notification\n-# from .serializers import NotificationSerializer\n+from rest_framework import viewsets, status\n+from rest_framework.response import Response\n+from rest_framework.permissions import IsAuthenticated\n+from .models import Notification\n+from .serializers import NotificationSerializer\n \n-# class NotificationViewSet(viewsets.ModelViewSet):\n-#     \"\"\"\n-#     API for managing notifications.\n-#     - Users only see their own notifications.\n-#     - Superusers can see all notifications.\n-#     \"\"\"\n-#     serializer_class = NotificationSerializer\n-#     permission_classes = [IsAuthenticated]\n+class NotificationViewSet(viewsets.ModelViewSet):\n+    \"\"\"\n+    API for managing notifications.\n+    - Users only see their own notifications.\n+    - Superusers can see all notifications.\n+    \"\"\"\n+    serializer_class = NotificationSerializer\n+    permission_classes = [IsAuthenticated]\n \n-#     def get_queryset(self):\n-#         if self.request.user.is_superuser:\n-#             return Notification.objects.all().order_by(\"-timestamp\")\n-#         return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n+    def get_queryset(self):\n+        if self.request.user.is_superuser:\n+            return Notification.objects.all().order_by(\"-timestamp\")\n+        return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n \n-#     def update(self, request, *args, **kwargs):\n-#         instance = self.get_object()\n-#         if request.user != instance.user:\n-#             return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n+    def update(self, request, *args, **kwargs):\n+        instance = self.get_object()\n+        if request.user != instance.user:\n+            return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n \n-#         instance.is_read = True\n-#         instance.save()\n-#         return Response({\"message\": \"Notification marked as read\"}, status=status.HTTP_200_OK)\n+        instance.is_read = True\n+        instance.save()\n+        return Response({\"message\": \"Notification marked as read\"}, status=status.HTTP_200_OK)\n"
                },
                {
                    "date": 1740121129305,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,28 +1,50 @@\n from rest_framework import viewsets, status\n from rest_framework.response import Response\n from rest_framework.permissions import IsAuthenticated\n+from rest_framework.decorators import action\n from .models import Notification\n from .serializers import NotificationSerializer\n \n class NotificationViewSet(viewsets.ModelViewSet):\n     \"\"\"\n     API for managing notifications.\n     - Users only see their own notifications.\n     - Superusers can see all notifications.\n+    - Users can mark notifications as read.\n+    - Users can delete their own notifications.\n+    - Superusers can delete all notifications.\n     \"\"\"\n     serializer_class = NotificationSerializer\n     permission_classes = [IsAuthenticated]\n \n     def get_queryset(self):\n+        \"\"\"Return notifications based on user role.\"\"\"\n         if self.request.user.is_superuser:\n             return Notification.objects.all().order_by(\"-timestamp\")\n         return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n \n     def update(self, request, *args, **kwargs):\n+        \"\"\"Mark a single notification as read.\"\"\"\n         instance = self.get_object()\n         if request.user != instance.user:\n             return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n \n         instance.is_read = True\n         instance.save()\n         return Response({\"message\": \"Notification marked as read\"}, status=status.HTTP_200_OK)\n+\n+    @action(detail=False, methods=[\"POST\"])\n+    def mark_all_as_read(self, request):\n+        \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n+        notifications = Notification.objects.filter(user=request.user, is_read=False)\n+        notifications.update(is_read=True)\n+        return Response({\"message\": \"All notifications marked as read\"}, status=status.HTTP_200_OK)\n+\n+    @action(detail=False, methods=[\"DELETE\"])\n+    def delete_all(self, request):\n+        \"\"\"Delete all notifications for the requesting user.\"\"\"\n+        if request.user.is_superuser:\n+            Notification.objects.all().delete()\n+        else:\n+            Notification.objects.filter(user=request.user).delete()\n+        return Response({\"message\": \"All notifications deleted\"}, status=status.HTTP_200_OK)\n"
                },
                {
                    "date": 1740123533292,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,17 @@\n+import sys\n+import traceback\n+import logging\n from rest_framework import viewsets, status\n from rest_framework.response import Response\n from rest_framework.permissions import IsAuthenticated\n from rest_framework.decorators import action\n from .models import Notification\n from .serializers import NotificationSerializer\n \n+# Set up logging for debugging errors\n+logger = logging.getLogger(__name__)\n+\n class NotificationViewSet(viewsets.ModelViewSet):\n     \"\"\"\n     API for managing notifications.\n     - Users only see their own notifications.\n@@ -17,34 +23,64 @@\n     serializer_class = NotificationSerializer\n     permission_classes = [IsAuthenticated]\n \n     def get_queryset(self):\n-        \"\"\"Return notifications based on user role.\"\"\"\n-        if self.request.user.is_superuser:\n-            return Notification.objects.all().order_by(\"-timestamp\")\n-        return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n+        \"\"\"Return notifications based on user role with recursion handling.\"\"\"\n+        try:\n+            if self.request.user.is_superuser:\n+                return Notification.objects.all().order_by(\"-timestamp\")\n+            return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n+        except RecursionError:\n+            logger.error(\"RecursionError in get_queryset() - Too many recursive calls.\", exc_info=True)\n+            sys.setrecursionlimit(5000)  # Increase recursion limit safely\n+            return Notification.objects.none()  # Return empty queryset to prevent API failure\n \n     def update(self, request, *args, **kwargs):\n-        \"\"\"Mark a single notification as read.\"\"\"\n-        instance = self.get_object()\n-        if request.user != instance.user:\n-            return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n+        \"\"\"Mark a single notification as read with recursion handling.\"\"\"\n+        try:\n+            instance = self.get_object()\n+            if request.user != instance.user:\n+                return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n \n-        instance.is_read = True\n-        instance.save()\n-        return Response({\"message\": \"Notification marked as read\"}, status=status.HTTP_200_OK)\n+            instance.is_read = True\n+            instance.save()\n+            return Response({\"message\": \"Notification marked as read\"}, status=status.HTTP_200_OK)\n+        except RecursionError:\n+            logger.error(\"RecursionError in update() - Too many recursive calls.\", exc_info=True)\n+            sys.setrecursionlimit(5000)\n+            return Response({\"error\": \"Recursion limit exceeded\"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+        except Exception as e:\n+            logger.error(f\"Error in update(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while marking notification as read.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=[\"POST\"])\n     def mark_all_as_read(self, request):\n-        \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n-        notifications = Notification.objects.filter(user=request.user, is_read=False)\n-        notifications.update(is_read=True)\n-        return Response({\"message\": \"All notifications marked as read\"}, status=status.HTTP_200_OK)\n+        \"\"\"Mark all notifications as read for the requesting user with recursion handling.\"\"\"\n+        try:\n+            notifications = Notification.objects.filter(user=request.user, is_read=False)\n+            count = notifications.update(is_read=True)\n+            return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n+        except RecursionError:\n+            logger.error(\"RecursionError in mark_all_as_read() - Too many recursive calls.\", exc_info=True)\n+            return Response({\"error\": \"Recursion limit exceeded\"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+        except Exception as e:\n+            logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=[\"DELETE\"])\n     def delete_all(self, request):\n-        \"\"\"Delete all notifications for the requesting user.\"\"\"\n-        if request.user.is_superuser:\n-            Notification.objects.all().delete()\n-        else:\n-            Notification.objects.filter(user=request.user).delete()\n-        return Response({\"message\": \"All notifications deleted\"}, status=status.HTTP_200_OK)\n+        \"\"\"Delete all notifications for the requesting user with recursion handling.\"\"\"\n+        try:\n+            if request.user.is_superuser:\n+                count, _ = Notification.objects.all().delete()\n+            else:\n+                count, _ = Notification.objects.filter(user=request.user).delete()\n+            return Response({\"message\": f\"{count} notifications deleted\"}, status=status.HTTP_200_OK)\n+        except RecursionError:\n+            logger.error(\"RecursionError in delete_all() - Too many recursive calls.\", exc_info=True)\n+            return Response({\"error\": \"Recursion limit exceeded\"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+        except Exception as e:\n+            logger.error(f\"Error in delete_all(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while deleting notifications.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n"
                },
                {
                    "date": 1740896719023,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,17 +34,20 @@\n             sys.setrecursionlimit(5000)  # Increase recursion limit safely\n             return Notification.objects.none()  # Return empty queryset to prevent API failure\n \n     def update(self, request, *args, **kwargs):\n-        \"\"\"Mark a single notification as read with recursion handling.\"\"\"\n+        \"\"\"Mark a single notification as read for the current user with recursion handling.\"\"\"\n         try:\n             instance = self.get_object()\n             if request.user != instance.user:\n                 return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n \n-            instance.is_read = True\n+            # Add the current user to the read_by field\n+            instance.read_by.add(request.user)\n             instance.save()\n-            return Response({\"message\": \"Notification marked as read\"}, status=status.HTTP_200_OK)\n+\n+            serializer = self.get_serializer(instance, context={'request': request})\n+            return Response(serializer.data, status=status.HTTP_200_OK)\n         except RecursionError:\n             logger.error(\"RecursionError in update() - Too many recursive calls.\", exc_info=True)\n             sys.setrecursionlimit(5000)\n             return Response({\"error\": \"Recursion limit exceeded\"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n@@ -56,10 +59,12 @@\n     @action(detail=False, methods=[\"POST\"])\n     def mark_all_as_read(self, request):\n         \"\"\"Mark all notifications as read for the requesting user with recursion handling.\"\"\"\n         try:\n-            notifications = Notification.objects.filter(user=request.user, is_read=False)\n-            count = notifications.update(is_read=True)\n+            notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n+            for notification in notifications:\n+                notification.read_by.add(request.user)\n+            count = notifications.count()\n             return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n         except RecursionError:\n             logger.error(\"RecursionError in mark_all_as_read() - Too many recursive calls.\", exc_info=True)\n             return Response({\"error\": \"Recursion limit exceeded\"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n@@ -82,5 +87,5 @@\n             return Response({\"error\": \"Recursion limit exceeded\"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n         except Exception as e:\n             logger.error(f\"Error in delete_all(): {str(e)}\", exc_info=True)\n             return Response({\"error\": \"An error occurred while deleting notifications.\"},\n-                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740897182954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,23 +56,24 @@\n             return Response({\"error\": \"An error occurred while marking notification as read.\"},\n                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=[\"POST\"])\n-    def mark_all_as_read(self, request):\n-        \"\"\"Mark all notifications as read for the requesting user with recursion handling.\"\"\"\n-        try:\n-            notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n-            for notification in notifications:\n-                notification.read_by.add(request.user)\n-            count = notifications.count()\n-            return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n-        except RecursionError:\n-            logger.error(\"RecursionError in mark_all_as_read() - Too many recursive calls.\", exc_info=True)\n-            return Response({\"error\": \"Recursion limit exceeded\"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n-        except Exception as e:\n-            logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n-            return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n-                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+def mark_all_as_read(self, request):\n+    \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n+    try:\n+        # Get all notifications for the current user that haven't been read by them\n+        notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n+        \n+        # Add the current user to the read_by field of each notification\n+        for notification in notifications:\n+            notification.read_by.add(request.user)\n+        \n+        count = notifications.count()\n+        return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n+    except Exception as e:\n+        logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n+        return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n+                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=[\"DELETE\"])\n     def delete_all(self, request):\n         \"\"\"Delete all notifications for the requesting user with recursion handling.\"\"\"\n"
                },
                {
                    "date": 1740897188087,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,24 +56,24 @@\n             return Response({\"error\": \"An error occurred while marking notification as read.\"},\n                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=[\"POST\"])\n-def mark_all_as_read(self, request):\n-    \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n-    try:\n-        # Get all notifications for the current user that haven't been read by them\n-        notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n-        \n-        # Add the current user to the read_by field of each notification\n-        for notification in notifications:\n-            notification.read_by.add(request.user)\n-        \n-        count = notifications.count()\n-        return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n-    except Exception as e:\n-        logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n-        return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n-                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+    def mark_all_as_read(self, request):\n+        \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n+        try:\n+            # Get all notifications for the current user that haven't been read by them\n+            notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n+            \n+            # Add the current user to the read_by field of each notification\n+            for notification in notifications:\n+                notification.read_by.add(request.user)\n+            \n+            count = notifications.count()\n+            return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n+        except Exception as e:\n+            logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=[\"DELETE\"])\n     def delete_all(self, request):\n         \"\"\"Delete all notifications for the requesting user with recursion handling.\"\"\"\n"
                },
                {
                    "date": 1740897286083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,25 +56,30 @@\n             return Response({\"error\": \"An error occurred while marking notification as read.\"},\n                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=[\"POST\"])\n-    def mark_all_as_read(self, request):\n-        \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n-        try:\n-            # Get all notifications for the current user that haven't been read by them\n-            notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n-            \n-            # Add the current user to the read_by field of each notification\n-            for notification in notifications:\n-                notification.read_by.add(request.user)\n-            \n-            count = notifications.count()\n-            return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n-        except Exception as e:\n-            logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n-            return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n-                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+def mark_all_as_read(self, request):\n+    \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n+    try:\n+        print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n+        print(f\"🔍 Current user: {request.user}\")  # Debugging\n \n+        # Get all notifications for the current user that haven't been read by them\n+        notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n+        print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n+\n+        # Add the current user to the read_by field of each notification\n+        for notification in notifications:\n+            notification.read_by.add(request.user)\n+            print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n+\n+        count = notifications.count()\n+        return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n+    except Exception as e:\n+        logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n+        return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n+                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+\n     @action(detail=False, methods=[\"DELETE\"])\n     def delete_all(self, request):\n         \"\"\"Delete all notifications for the requesting user with recursion handling.\"\"\"\n         try:\n"
                },
                {
                    "date": 1740897452070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,29 +56,29 @@\n             return Response({\"error\": \"An error occurred while marking notification as read.\"},\n                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=[\"POST\"])\n-def mark_all_as_read(self, request):\n-    \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n-    try:\n-        print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n-        print(f\"🔍 Current user: {request.user}\")  # Debugging\n+    def mark_all_as_read(self, request):\n+        \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n+        try:\n+            print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n+            print(f\"🔍 Current user: {request.user}\")  # Debugging\n \n-        # Get all notifications for the current user that haven't been read by them\n-        notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n-        print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n+            # Get all notifications for the current user that haven't been read by them\n+            notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n+            print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n \n-        # Add the current user to the read_by field of each notification\n-        for notification in notifications:\n-            notification.read_by.add(request.user)\n-            print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n+            # Add the current user to the read_by field of each notification\n+            for notification in notifications:\n+                notification.read_by.add(request.user)\n+                print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n \n-        count = notifications.count()\n-        return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n-    except Exception as e:\n-        logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n-        return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n-                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+            count = notifications.count()\n+            return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n+        except Exception as e:\n+            logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=[\"DELETE\"])\n     def delete_all(self, request):\n         \"\"\"Delete all notifications for the requesting user with recursion handling.\"\"\"\n"
                },
                {
                    "date": 1740897673928,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,11 @@\n-import sys\n-import traceback\n-import logging\n from rest_framework import viewsets, status\n from rest_framework.response import Response\n from rest_framework.permissions import IsAuthenticated\n from rest_framework.decorators import action\n from .models import Notification\n from .serializers import NotificationSerializer\n+import logging\n \n # Set up logging for debugging errors\n logger = logging.getLogger(__name__)\n \n@@ -23,42 +21,15 @@\n     serializer_class = NotificationSerializer\n     permission_classes = [IsAuthenticated]\n \n     def get_queryset(self):\n-        \"\"\"Return notifications based on user role with recursion handling.\"\"\"\n-        try:\n-            if self.request.user.is_superuser:\n-                return Notification.objects.all().order_by(\"-timestamp\")\n-            return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n-        except RecursionError:\n-            logger.error(\"RecursionError in get_queryset() - Too many recursive calls.\", exc_info=True)\n-            sys.setrecursionlimit(5000)  # Increase recursion limit safely\n-            return Notification.objects.none()  # Return empty queryset to prevent API failure\n+        \"\"\"Return notifications based on user role.\"\"\"\n+        if self.request.user.is_superuser:\n+            return Notification.objects.all().order_by(\"-timestamp\")\n+        return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n \n-    def update(self, request, *args, **kwargs):\n-        \"\"\"Mark a single notification as read for the current user with recursion handling.\"\"\"\n-        try:\n-            instance = self.get_object()\n-            if request.user != instance.user:\n-                return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n-\n-            # Add the current user to the read_by field\n-            instance.read_by.add(request.user)\n-            instance.save()\n-\n-            serializer = self.get_serializer(instance, context={'request': request})\n-            return Response(serializer.data, status=status.HTTP_200_OK)\n-        except RecursionError:\n-            logger.error(\"RecursionError in update() - Too many recursive calls.\", exc_info=True)\n-            sys.setrecursionlimit(5000)\n-            return Response({\"error\": \"Recursion limit exceeded\"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n-        except Exception as e:\n-            logger.error(f\"Error in update(): {str(e)}\", exc_info=True)\n-            return Response({\"error\": \"An error occurred while marking notification as read.\"},\n-                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n-\n-    @action(detail=False, methods=[\"POST\"])\n-    def mark_all_as_read(self, request):\n+    @action(detail=False, methods=['post'], name=\"Mark All as Read\", url_path=\"mark_all_as_read\")\n+    def mark_all_as_read(self, request, *args, **kwargs):\n         \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n         try:\n             print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n             print(f\"🔍 Current user: {request.user}\")  # Debugging\n@@ -78,20 +49,36 @@\n             logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n             return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n-    @action(detail=False, methods=[\"DELETE\"])\n-    def delete_all(self, request):\n-        \"\"\"Delete all notifications for the requesting user with recursion handling.\"\"\"\n+    @action(detail=False, methods=['delete'], name=\"Delete All Notifications\", url_path=\"delete_all\")\n+    def delete_all(self, request, *args, **kwargs):\n+        \"\"\"Delete all notifications for the requesting user.\"\"\"\n         try:\n             if request.user.is_superuser:\n                 count, _ = Notification.objects.all().delete()\n             else:\n                 count, _ = Notification.objects.filter(user=request.user).delete()\n             return Response({\"message\": f\"{count} notifications deleted\"}, status=status.HTTP_200_OK)\n-        except RecursionError:\n-            logger.error(\"RecursionError in delete_all() - Too many recursive calls.\", exc_info=True)\n-            return Response({\"error\": \"Recursion limit exceeded\"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n         except Exception as e:\n             logger.error(f\"Error in delete_all(): {str(e)}\", exc_info=True)\n             return Response({\"error\": \"An error occurred while deleting notifications.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+\n+    @action(detail=True, methods=['post'], name=\"Mark as Read\", url_path=\"mark_as_read\")\n+    def mark_as_read(self, request, pk=None, *args, **kwargs):\n+        \"\"\"Mark a single notification as read for the requesting user.\"\"\"\n+        try:\n+            notification = self.get_object()\n+            if request.user != notification.user:\n+                return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n+\n+            # Add the current user to the read_by field\n+            notification.read_by.add(request.user)\n+            notification.save()\n+\n+            serializer = self.get_serializer(notification, context={'request': request})\n+            return Response(serializer.data, status=status.HTTP_200_OK)\n+        except Exception as e:\n+            logger.error(f\"Error in mark_as_read(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while marking the notification as read.\"},\n                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740897817806,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,29 +27,29 @@\n             return Notification.objects.all().order_by(\"-timestamp\")\n         return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n \n     @action(detail=False, methods=['post'], name=\"Mark All as Read\", url_path=\"mark_all_as_read\")\n-    def mark_all_as_read(self, request, *args, **kwargs):\n-        \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n-        try:\n-            print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n-            print(f\"🔍 Current user: {request.user}\")  # Debugging\n+def mark_all_as_read(self, request, *args, **kwargs):\n+    \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n+    try:\n+        print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n+        print(f\"🔍 Current user: {request.user}\")  # Debugging\n \n-            # Get all notifications for the current user that haven't been read by them\n-            notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n-            print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n+        # Get all notifications for the current user that haven't been read by them\n+        notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n+        print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n \n-            # Add the current user to the read_by field of each notification\n-            for notification in notifications:\n-                notification.read_by.add(request.user)\n-                print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n+        # Add the current user to the read_by field of each notification\n+        for notification in notifications:\n+            notification.read_by.add(request.user)\n+            print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n \n-            count = notifications.count()\n-            return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n-        except Exception as e:\n-            logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n-            return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n-                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+        count = notifications.count()\n+        return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n+    except Exception as e:\n+        logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n+        return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n+                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=['delete'], name=\"Delete All Notifications\", url_path=\"delete_all\")\n     def delete_all(self, request, *args, **kwargs):\n         \"\"\"Delete all notifications for the requesting user.\"\"\"\n"
                },
                {
                    "date": 1740897832068,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,29 +27,29 @@\n             return Notification.objects.all().order_by(\"-timestamp\")\n         return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n \n     @action(detail=False, methods=['post'], name=\"Mark All as Read\", url_path=\"mark_all_as_read\")\n-def mark_all_as_read(self, request, *args, **kwargs):\n-    \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n-    try:\n-        print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n-        print(f\"🔍 Current user: {request.user}\")  # Debugging\n+    def mark_all_as_read(self, request, *args, **kwargs):\n+        \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n+        try:\n+            print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n+            print(f\"🔍 Current user: {request.user}\")  # Debugging\n \n-        # Get all notifications for the current user that haven't been read by them\n-        notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n-        print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n+            # Get all notifications for the current user that haven't been read by them\n+            notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n+            print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n \n-        # Add the current user to the read_by field of each notification\n-        for notification in notifications:\n-            notification.read_by.add(request.user)\n-            print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n+            # Add the current user to the read_by field of each notification\n+            for notification in notifications:\n+                notification.read_by.add(request.user)\n+                print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n \n-        count = notifications.count()\n-        return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n-    except Exception as e:\n-        logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n-        return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n-                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+            count = notifications.count()\n+            return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n+        except Exception as e:\n+            logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=['delete'], name=\"Delete All Notifications\", url_path=\"delete_all\")\n     def delete_all(self, request, *args, **kwargs):\n         \"\"\"Delete all notifications for the requesting user.\"\"\"\n@@ -64,21 +64,24 @@\n             return Response({\"error\": \"An error occurred while deleting notifications.\"},\n                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=True, methods=['post'], name=\"Mark as Read\", url_path=\"mark_as_read\")\n-    def mark_as_read(self, request, pk=None, *args, **kwargs):\n-        \"\"\"Mark a single notification as read for the requesting user.\"\"\"\n-        try:\n-            notification = self.get_object()\n-            if request.user != notification.user:\n-                return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n+def mark_as_read(self, request, pk=None, *args, **kwargs):\n+    \"\"\"Mark a single notification as read for the requesting user.\"\"\"\n+    try:\n+        print(\"🔍 mark_as_read action triggered\")  # Debugging\n+        notification = self.get_object()\n+        print(f\"🔍 Notification ID: {notification.id}\")  # Debugging\n \n-            # Add the current user to the read_by field\n-            notification.read_by.add(request.user)\n-            notification.save()\n+        if request.user != notification.user:\n\\ No newline at end of file\n+            return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n \n-            serializer = self.get_serializer(notification, context={'request': request})\n-            return Response(serializer.data, status=status.HTTP_200_OK)\n-        except Exception as e:\n-            logger.error(f\"Error in mark_as_read(): {str(e)}\", exc_info=True)\n-            return Response({\"error\": \"An error occurred while marking the notification as read.\"},\n-                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+        # Add the current user to the read_by field\n+        notification.read_by.add(request.user)\n+        print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n+\n+        serializer = self.get_serializer(notification, context={'request': request})\n+        return Response(serializer.data, status=status.HTTP_200_OK)\n+    except Exception as e:\n+        logger.error(f\"Error in mark_as_read(): {str(e)}\", exc_info=True)\n+        return Response({\"error\": \"An error occurred while marking the notification as read.\"},\n+                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740897837223,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,24 +64,24 @@\n             return Response({\"error\": \"An error occurred while deleting notifications.\"},\n                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=True, methods=['post'], name=\"Mark as Read\", url_path=\"mark_as_read\")\n-def mark_as_read(self, request, pk=None, *args, **kwargs):\n-    \"\"\"Mark a single notification as read for the requesting user.\"\"\"\n-    try:\n-        print(\"🔍 mark_as_read action triggered\")  # Debugging\n-        notification = self.get_object()\n-        print(f\"🔍 Notification ID: {notification.id}\")  # Debugging\n+    def mark_as_read(self, request, pk=None, *args, **kwargs):\n+        \"\"\"Mark a single notification as read for the requesting user.\"\"\"\n+        try:\n+            print(\"🔍 mark_as_read action triggered\")  # Debugging\n+            notification = self.get_object()\n+            print(f\"🔍 Notification ID: {notification.id}\")  # Debugging\n \n-        if request.user != notification.user:\n-            return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n+            if request.user != notification.user:\n+                return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n \n-        # Add the current user to the read_by field\n-        notification.read_by.add(request.user)\n\\ No newline at end of file\n-        print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n+            # Add the current user to the read_by field\n+            notification.read_by.add(request.user)\n+            print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n \n-        serializer = self.get_serializer(notification, context={'request': request})\n-        return Response(serializer.data, status=status.HTTP_200_OK)\n-    except Exception as e:\n-        logger.error(f\"Error in mark_as_read(): {str(e)}\", exc_info=True)\n-        return Response({\"error\": \"An error occurred while marking the notification as read.\"},\n-                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+            serializer = self.get_serializer(notification, context={'request': request})\n+            return Response(serializer.data, status=status.HTTP_200_OK)\n+        except Exception as e:\n+            logger.error(f\"Error in mark_as_read(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while marking the notification as read.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741072479930,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,30 +27,33 @@\n             return Notification.objects.all().order_by(\"-timestamp\")\n         return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n \n     @action(detail=False, methods=['post'], name=\"Mark All as Read\", url_path=\"mark_all_as_read\")\n-    def mark_all_as_read(self, request, *args, **kwargs):\n-        \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n-        try:\n-            print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n-            print(f\"🔍 Current user: {request.user}\")  # Debugging\n+def mark_all_as_read(self, request, *args, **kwargs):\n+    \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n+    try:\n+        print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n+        print(f\"🔍 Current user: {request.user}\")  # Debugging\n \n-            # Get all notifications for the current user that haven't been read by them\n-            notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n-            print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n+        if not request.user.is_authenticated:\n+            return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n \n-            # Add the current user to the read_by field of each notification\n-            for notification in notifications:\n-                notification.read_by.add(request.user)\n-                print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n+        # Get all notifications for the current user that haven't been read by them\n+        notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n+        print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n \n-            count = notifications.count()\n-            return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n-        except Exception as e:\n-            logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n-            return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n-                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+        # Add the current user to the read_by field of each notification\n+        for notification in notifications:\n+            notification.read_by.add(request.user)\n+            print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n \n+        count = notifications.count()\n+        return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n+    except Exception as e:\n+        logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n+        return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n+                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+\n     @action(detail=False, methods=['delete'], name=\"Delete All Notifications\", url_path=\"delete_all\")\n     def delete_all(self, request, *args, **kwargs):\n         \"\"\"Delete all notifications for the requesting user.\"\"\"\n         try:\n"
                },
                {
                    "date": 1741072485759,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,32 +27,32 @@\n             return Notification.objects.all().order_by(\"-timestamp\")\n         return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n \n     @action(detail=False, methods=['post'], name=\"Mark All as Read\", url_path=\"mark_all_as_read\")\n-def mark_all_as_read(self, request, *args, **kwargs):\n-    \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n-    try:\n-        print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n-        print(f\"🔍 Current user: {request.user}\")  # Debugging\n+    def mark_all_as_read(self, request, *args, **kwargs):\n+        \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n+        try:\n+            print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n+            print(f\"🔍 Current user: {request.user}\")  # Debugging\n \n-        if not request.user.is_authenticated:\n-            return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n+            if not request.user.is_authenticated:\n+                return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n \n-        # Get all notifications for the current user that haven't been read by them\n-        notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n-        print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n+            # Get all notifications for the current user that haven't been read by them\n+            notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n+            print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n \n-        # Add the current user to the read_by field of each notification\n-        for notification in notifications:\n-            notification.read_by.add(request.user)\n-            print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n+            # Add the current user to the read_by field of each notification\n+            for notification in notifications:\n+                notification.read_by.add(request.user)\n+                print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n \n-        count = notifications.count()\n-        return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n-    except Exception as e:\n-        logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n-        return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n-                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+            count = notifications.count()\n+            return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n+        except Exception as e:\n+            logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=['delete'], name=\"Delete All Notifications\", url_path=\"delete_all\")\n     def delete_all(self, request, *args, **kwargs):\n         \"\"\"Delete all notifications for the requesting user.\"\"\"\n"
                },
                {
                    "date": 1741072501410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,21 +53,27 @@\n             return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=['delete'], name=\"Delete All Notifications\", url_path=\"delete_all\")\n-    def delete_all(self, request, *args, **kwargs):\n-        \"\"\"Delete all notifications for the requesting user.\"\"\"\n-        try:\n-            if request.user.is_superuser:\n-                count, _ = Notification.objects.all().delete()\n-            else:\n-                count, _ = Notification.objects.filter(user=request.user).delete()\n-            return Response({\"message\": f\"{count} notifications deleted\"}, status=status.HTTP_200_OK)\n-        except Exception as e:\n-            logger.error(f\"Error in delete_all(): {str(e)}\", exc_info=True)\n-            return Response({\"error\": \"An error occurred while deleting notifications.\"},\n-                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+def delete_all(self, request, *args, **kwargs):\n+    \"\"\"Delete all notifications for the requesting user.\"\"\"\n+    try:\n+        if not request.user.is_authenticated:\n+            return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n \n+        if request.user.is_superuser:\n+            count, _ = Notification.objects.all().delete()\n+            print(f\"🔍 Superuser deleted all notifications: {count}\")  # Debugging\n+        else:\n+            count, _ = Notification.objects.filter(user=request.user).delete()\n+            print(f\"🔍 User {request.user} deleted {count} notifications\")  # Debugging\n+\n+        return Response({\"message\": f\"{count} notifications deleted\"}, status=status.HTTP_200_OK)\n+    except Exception as e:\n+        logger.error(f\"Error in delete_all(): {str(e)}\", exc_info=True)\n+        return Response({\"error\": \"An error occurred while deleting notifications.\"},\n+                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+\n     @action(detail=True, methods=['post'], name=\"Mark as Read\", url_path=\"mark_as_read\")\n     def mark_as_read(self, request, pk=None, *args, **kwargs):\n         \"\"\"Mark a single notification as read for the requesting user.\"\"\"\n         try:\n"
                },
                {
                    "date": 1741072518231,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,44 +53,48 @@\n             return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n     @action(detail=False, methods=['delete'], name=\"Delete All Notifications\", url_path=\"delete_all\")\n-def delete_all(self, request, *args, **kwargs):\n-    \"\"\"Delete all notifications for the requesting user.\"\"\"\n+    def delete_all(self, request, *args, **kwargs):\n+        \"\"\"Delete all notifications for the requesting user.\"\"\"\n+        try:\n+            if not request.user.is_authenticated:\n+                return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n+\n+            if request.user.is_superuser:\n+                count, _ = Notification.objects.all().delete()\n+                print(f\"🔍 Superuser deleted all notifications: {count}\")  # Debugging\n+            else:\n+                count, _ = Notification.objects.filter(user=request.user).delete()\n+                print(f\"🔍 User {request.user} deleted {count} notifications\")  # Debugging\n+\n+            return Response({\"message\": f\"{count} notifications deleted\"}, status=status.HTTP_200_OK)\n+        except Exception as e:\n+            logger.error(f\"Error in delete_all(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while deleting notifications.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+\n+    @action(detail=True, methods=['post'], name=\"Mark as Read\", url_path=\"mark_as_read\")\n+def mark_as_read(self, request, pk=None, *args, **kwargs):\n+    \"\"\"Mark a single notification as read for the requesting user.\"\"\"\n     try:\n+        print(\"🔍 mark_as_read action triggered\")  # Debugging\n+\n         if not request.user.is_authenticated:\n             return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n \n-        if request.user.is_superuser:\n-            count, _ = Notification.objects.all().delete()\n-            print(f\"🔍 Superuser deleted all notifications: {count}\")  # Debugging\n-        else:\n-            count, _ = Notification.objects.filter(user=request.user).delete()\n-            print(f\"🔍 User {request.user} deleted {count} notifications\")  # Debugging\n+        notification = self.get_object()\n+        print(f\"🔍 Notification ID: {notification.id}\")  # Debugging\n \n-        return Response({\"message\": f\"{count} notifications deleted\"}, status=status.HTTP_200_OK)\n\\ No newline at end of file\n-    except Exception as e:\n-        logger.error(f\"Error in delete_all(): {str(e)}\", exc_info=True)\n-        return Response({\"error\": \"An error occurred while deleting notifications.\"},\n-                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+        if request.user != notification.user:\n+            return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n \n-    @action(detail=True, methods=['post'], name=\"Mark as Read\", url_path=\"mark_as_read\")\n-    def mark_as_read(self, request, pk=None, *args, **kwargs):\n-        \"\"\"Mark a single notification as read for the requesting user.\"\"\"\n-        try:\n-            print(\"🔍 mark_as_read action triggered\")  # Debugging\n-            notification = self.get_object()\n-            print(f\"🔍 Notification ID: {notification.id}\")  # Debugging\n+        # Add the current user to the read_by field\n+        notification.read_by.add(request.user)\n+        print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n \n-            if request.user != notification.user:\n-                return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n-\n-            # Add the current user to the read_by field\n-            notification.read_by.add(request.user)\n-            print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n-\n-            serializer = self.get_serializer(notification, context={'request': request})\n-            return Response(serializer.data, status=status.HTTP_200_OK)\n-        except Exception as e:\n-            logger.error(f\"Error in mark_as_read(): {str(e)}\", exc_info=True)\n-            return Response({\"error\": \"An error occurred while marking the notification as read.\"},\n-                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+        serializer = self.get_serializer(notification, context={'request': request})\n+        return Response(serializer.data, status=status.HTTP_200_OK)\n+    except Exception as e:\n+        logger.error(f\"Error in mark_as_read(): {str(e)}\", exc_info=True)\n+        return Response({\"error\": \"An error occurred while marking the notification as read.\"},\n+                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741072528368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,29 +72,29 @@\n             logger.error(f\"Error in delete_all(): {str(e)}\", exc_info=True)\n             return Response({\"error\": \"An error occurred while deleting notifications.\"},\n                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n \n-    @action(detail=True, methods=['post'], name=\"Mark as Read\", url_path=\"mark_as_read\")\n-def mark_as_read(self, request, pk=None, *args, **kwargs):\n-    \"\"\"Mark a single notification as read for the requesting user.\"\"\"\n-    try:\n-        print(\"🔍 mark_as_read action triggered\")  # Debugging\n+    @action(detail=False, methods=['post'], name=\"Mark as Read\", url_path=\"mark_as_read\")\n+    def mark_as_read(self, request, pk=None, *args, **kwargs):\n+        \"\"\"Mark a single notification as read for the requesting user.\"\"\"\n+        try:\n+            print(\"🔍 mark_as_read action triggered\")  # Debugging\n \n-        if not request.user.is_authenticated:\n-            return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n+            if not request.user.is_authenticated:\n+                return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n \n-        notification = self.get_object()\n-        print(f\"🔍 Notification ID: {notification.id}\")  # Debugging\n+            notification = self.get_object()\n+            print(f\"🔍 Notification ID: {notification.id}\")  # Debugging\n \n-        if request.user != notification.user:\n-            return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n+            if request.user != notification.user:\n+                return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n \n-        # Add the current user to the read_by field\n-        notification.read_by.add(request.user)\n-        print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n+            # Add the current user to the read_by field\n+            notification.read_by.add(request.user)\n+            print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n \n-        serializer = self.get_serializer(notification, context={'request': request})\n-        return Response(serializer.data, status=status.HTTP_200_OK)\n-    except Exception as e:\n+            serializer = self.get_serializer(notification, context={'request': request})\n+            return Response(serializer.data, status=status.HTTP_200_OK)\n+        except Exception as e:\n         logger.error(f\"Error in mark_as_read(): {str(e)}\", exc_info=True)\n         return Response({\"error\": \"An error occurred while marking the notification as read.\"},\n                         status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741072569406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,7 +94,7 @@\n \n             serializer = self.get_serializer(notification, context={'request': request})\n             return Response(serializer.data, status=status.HTTP_200_OK)\n         except Exception as e:\n-        logger.error(f\"Error in mark_as_read(): {str(e)}\", exc_info=True)\n-        return Response({\"error\": \"An error occurred while marking the notification as read.\"},\n-                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n\\ No newline at end of file\n+            logger.error(f\"Error in mark_as_read(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while marking the notification as read.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741072966070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,75 +26,30 @@\n         if self.request.user.is_superuser:\n             return Notification.objects.all().order_by(\"-timestamp\")\n         return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n \n-    @action(detail=False, methods=['post'], name=\"Mark All as Read\", url_path=\"mark_all_as_read\")\n-    def mark_all_as_read(self, request, *args, **kwargs):\n-        \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n-        try:\n-            print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n-            print(f\"🔍 Current user: {request.user}\")  # Debugging\n-\n-            if not request.user.is_authenticated:\n-                return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n-\n-            # Get all notifications for the current user that haven't been read by them\n-            notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n-            print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n-\n-            # Add the current user to the read_by field of each notification\n-            for notification in notifications:\n-                notification.read_by.add(request.user)\n-                print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n-\n-            count = notifications.count()\n-            return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n-        except Exception as e:\n-            logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n-            return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n-                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n-\n-    @action(detail=False, methods=['delete'], name=\"Delete All Notifications\", url_path=\"delete_all\")\n-    def delete_all(self, request, *args, **kwargs):\n-        \"\"\"Delete all notifications for the requesting user.\"\"\"\n-        try:\n-            if not request.user.is_authenticated:\n-                return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n-\n-            if request.user.is_superuser:\n-                count, _ = Notification.objects.all().delete()\n-                print(f\"🔍 Superuser deleted all notifications: {count}\")  # Debugging\n-            else:\n-                count, _ = Notification.objects.filter(user=request.user).delete()\n-                print(f\"🔍 User {request.user} deleted {count} notifications\")  # Debugging\n-\n-            return Response({\"message\": f\"{count} notifications deleted\"}, status=status.HTTP_200_OK)\n-        except Exception as e:\n-            logger.error(f\"Error in delete_all(): {str(e)}\", exc_info=True)\n-            return Response({\"error\": \"An error occurred while deleting notifications.\"},\n-                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n-\n-    @action(detail=False, methods=['post'], name=\"Mark as Read\", url_path=\"mark_as_read\")\n-    def mark_as_read(self, request, pk=None, *args, **kwargs):\n-        \"\"\"Mark a single notification as read for the requesting user.\"\"\"\n-        try:\n-            print(\"🔍 mark_as_read action triggered\")  # Debugging\n-\n-            if not request.user.is_authenticated:\n-                return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n-\n-            notification = self.get_object()\n-            print(f\"🔍 Notification ID: {notification.id}\")  # Debugging\n-\n-            if request.user != notification.user:\n-                return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n-\n-            # Add the current user to the read_by field\n-            notification.read_by.add(request.user)\n-            print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n-\n-            serializer = self.get_serializer(notification, context={'request': request})\n-            return Response(serializer.data, status=status.HTTP_200_OK)\n-        except Exception as e:\n-            logger.error(f\"Error in mark_as_read(): {str(e)}\", exc_info=True)\n-            return Response({\"error\": \"An error occurred while marking the notification as read.\"},\n-                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n\\ No newline at end of file\n+    04/Mar/2025 13:01:20] \"GET /api/notifications/ HTTP/1.1\" 200 95148\n+Method Not Allowed: /api/notifications/mark_all_as_read/\n+[04/Mar/2025 13:01:26] \"GET /api/notifications/mark_all_as_read/ HTTP/1.1\" 405 14502\n+[04/Mar/2025 13:01:29] \"GET /api/notifications/ HTTP/1.1\" 200 95148\n+[04/Mar/2025 13:01:30] \"GET /api/notifications/ HTTP/1.1\" 200 95148\n+[04/Mar/2025 13:01:31] \"GET /api/notifications/ HTTP/1.1\" 200 95148\n+[04/Mar/2025 13:01:31] \"GET /api/notifications/ HTTP/1.1\" 200 95148\n+[04/Mar/2025 13:01:31] \"GET /api/notifications/ HTTP/1.1\" 200 95148\n+Method Not Allowed: /api/notifications/mark_as_read/\n+[04/Mar/2025 13:01:33] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n+Method Not Allowed: /api/notifications/mark_as_read/\n+[04/Mar/2025 13:01:35] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n+Method Not Allowed: /api/notifications/mark_as_read/\n+[04/Mar/2025 13:01:35] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n+Method Not Allowed: /api/notifications/mark_as_read/\n+[04/Mar/2025 13:01:35] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n+Method Not Allowed: /api/notifications/mark_as_read/\n+[04/Mar/2025 13:01:35] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n+Method Not Allowed: /api/notifications/mark_as_read/\n+[04/Mar/2025 13:01:36] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n+Method Not Allowed: /api/notifications/mark_as_read/\n+[04/Mar/2025 13:01:36] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n+Method Not Allowed: /api/notifications/mark_as_read/\n+[04/Mar/2025 13:01:36] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n+Method Not Allowed: /api/notifications/mark_as_read/\n+[04/Mar/2025 13:01:36] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741073077045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,30 +26,75 @@\n         if self.request.user.is_superuser:\n             return Notification.objects.all().order_by(\"-timestamp\")\n         return Notification.objects.filter(user=self.request.user).order_by(\"-timestamp\")\n \n-    04/Mar/2025 13:01:20] \"GET /api/notifications/ HTTP/1.1\" 200 95148\n-Method Not Allowed: /api/notifications/mark_all_as_read/\n-[04/Mar/2025 13:01:26] \"GET /api/notifications/mark_all_as_read/ HTTP/1.1\" 405 14502\n-[04/Mar/2025 13:01:29] \"GET /api/notifications/ HTTP/1.1\" 200 95148\n-[04/Mar/2025 13:01:30] \"GET /api/notifications/ HTTP/1.1\" 200 95148\n-[04/Mar/2025 13:01:31] \"GET /api/notifications/ HTTP/1.1\" 200 95148\n-[04/Mar/2025 13:01:31] \"GET /api/notifications/ HTTP/1.1\" 200 95148\n-[04/Mar/2025 13:01:31] \"GET /api/notifications/ HTTP/1.1\" 200 95148\n-Method Not Allowed: /api/notifications/mark_as_read/\n-[04/Mar/2025 13:01:33] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n-Method Not Allowed: /api/notifications/mark_as_read/\n-[04/Mar/2025 13:01:35] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n-Method Not Allowed: /api/notifications/mark_as_read/\n-[04/Mar/2025 13:01:35] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n-Method Not Allowed: /api/notifications/mark_as_read/\n-[04/Mar/2025 13:01:35] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n-Method Not Allowed: /api/notifications/mark_as_read/\n-[04/Mar/2025 13:01:35] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n-Method Not Allowed: /api/notifications/mark_as_read/\n-[04/Mar/2025 13:01:36] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n-Method Not Allowed: /api/notifications/mark_as_read/\n-[04/Mar/2025 13:01:36] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n-Method Not Allowed: /api/notifications/mark_as_read/\n-[04/Mar/2025 13:01:36] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n-Method Not Allowed: /api/notifications/mark_as_read/\n-[04/Mar/2025 13:01:36] \"GET /api/notifications/mark_as_read/ HTTP/1.1\" 405 14458\n\\ No newline at end of file\n+    @action(detail=False, methods=['post'], name=\"Mark All as Read\", url_path=\"mark_all_as_read\")\n+    def mark_all_as_read(self, request, *args, **kwargs):\n+        \"\"\"Mark all notifications as read for the requesting user.\"\"\"\n+        try:\n+            print(\"🔍 mark_all_as_read action triggered\")  # Debugging\n+            print(f\"🔍 Current user: {request.user}\")  # Debugging\n+\n+            if not request.user.is_authenticated:\n+                return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n+\n+            # Get all notifications for the current user that haven't been read by them\n+            notifications = Notification.objects.filter(user=request.user).exclude(read_by=request.user)\n+            print(f\"🔍 Notifications to mark as read: {notifications.count()}\")  # Debugging\n+\n+            # Add the current user to the read_by field of each notification\n+            for notification in notifications:\n+                notification.read_by.add(request.user)\n+                print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n+\n+            count = notifications.count()\n+            return Response({\"message\": f\"{count} notifications marked as read\"}, status=status.HTTP_200_OK)\n+        except Exception as e:\n+            logger.error(f\"Error in mark_all_as_read(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while marking notifications as read.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+\n+    @action(detail=False, methods=['delete'], name=\"Delete All Notifications\", url_path=\"delete_all\")\n+    def delete_all(self, request, *args, **kwargs):\n+        \"\"\"Delete all notifications for the requesting user.\"\"\"\n+        try:\n+            if not request.user.is_authenticated:\n+                return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n+\n+            if request.user.is_superuser:\n+                count, _ = Notification.objects.all().delete()\n+                print(f\"🔍 Superuser deleted all notifications: {count}\")  # Debugging\n+            else:\n+                count, _ = Notification.objects.filter(user=request.user).delete()\n+                print(f\"🔍 User {request.user} deleted {count} notifications\")  # Debugging\n+\n+            return Response({\"message\": f\"{count} notifications deleted\"}, status=status.HTTP_200_OK)\n+        except Exception as e:\n+            logger.error(f\"Error in delete_all(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while deleting notifications.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n+\n+    @action(detail=Y, methods=['post'], name=\"Mark as Read\", url_path=\"mark_as_read\")\n+    def mark_as_read(self, request, pk=None, *args, **kwargs):\n+        \"\"\"Mark a single notification as read for the requesting user.\"\"\"\n+        try:\n+            print(\"🔍 mark_as_read action triggered\")  # Debugging\n+\n+            if not request.user.is_authenticated:\n+                return Response({\"error\": \"Authentication required\"}, status=status.HTTP_401_UNAUTHORIZED)\n+\n+            notification = self.get_object()\n+            print(f\"🔍 Notification ID: {notification.id}\")  # Debugging\n+\n+            if request.user != notification.user:\n+                return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n+\n+            # Add the current user to the read_by field\n+            notification.read_by.add(request.user)\n+            print(f\"🔍 Marked notification {notification.id} as read for user {request.user}\")  # Debugging\n+\n+            serializer = self.get_serializer(notification, context={'request': request})\n+            return Response(serializer.data, status=status.HTTP_200_OK)\n+        except Exception as e:\n+            logger.error(f\"Error in mark_as_read(): {str(e)}\", exc_info=True)\n+            return Response({\"error\": \"An error occurred while marking the notification as read.\"},\n+                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n\\ No newline at end of file\n"
                }
            ],
            "date": 1739869347719,
            "name": "Commit-0",
            "content": "from rest_framework import viewsets, status\nfrom rest_framework.response import Response\nfrom rest_framework.permissions import IsAuthenticated\nfrom .models import Notification\nfrom .serializers import NotificationSerializer\nfrom .permissions import DynamicModelPermission\n\nclass NotificationViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    API for managing notifications.\n    - Users can only see their own notifications.\n    - Superusers can see all notifications.\n    - Users can mark notifications as read.\n    \"\"\"\n    serializer_class = NotificationSerializer\n    permission_classes = [IsAuthenticated, DynamicModelPermission]\n\n    def get_queryset(self):\n        \"\"\"\n        Fetch only notifications related to the user.\n        \"\"\"\n        if self.request.user.is_superuser:\n            return Notification.objects.all().order_by(\"-created_at\")\n        return Notification.objects.filter(user=self.request.user).order_by(\"-created_at\")\n\n    def update(self, request, *args, **kwargs):\n        \"\"\"\n        Mark a notification as read.\n        \"\"\"\n        instance = self.get_object()\n        if instance.user != request.user:\n            return Response({\"detail\": \"Not allowed\"}, status=status.HTTP_403_FORBIDDEN)\n\n        instance.is_read = True\n        instance.save()\n        return Response({\"message\": \"Notification marked as read\"}, status=status.HTTP_200_OK)\n"
        }
    ]
}