{
    "sourceFile": "notify/signals.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 26,
            "patches": [
                {
                    "date": 1739869421688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739869432853,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,9 @@\n from django.dispatch import receiver\n from django.contrib.auth import get_user_model\n from .models import Notification\n from .utils import create_notification\n+from accounts.\n \n User = get_user_model()\n \n @receiver(post_save, sender=User)\n"
                },
                {
                    "date": 1739869440588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,10 +2,11 @@\n from django.dispatch import receiver\n from django.contrib.auth import get_user_model\n from .models import Notification\n from .utils import create_notification\n-from accounts.\n+from accounts.models import CustomUser as User\n \n+\n User = get_user_model()\n \n @receiver(post_save, sender=User)\n def notify_on_user_update(sender, instance, created, **kwargs):\n"
                },
                {
                    "date": 1739870065219,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,36 +1,85 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n-from django.contrib.auth import get_user_model\n+from django.contrib.auth.models import Permission\n+from django.apps import apps\n+from django.contrib.contenttypes.models import ContentType\n+from django.utils.timezone import now\n+from accounts.models import CustomUser\n from .models import Notification\n-from .utils import create_notification\n-from accounts.models import CustomUser as User\n \n \n-User = get_user_model()\n-\n-@receiver(post_save, sender=User)\n-def notify_on_user_update(sender, instance, created, **kwargs):\n+def notify_users(action, instance, user, model_name):\n     \"\"\"\n-    Notify users when they register or update their account.\n+    Helper function to create notifications for users based on the action type.\n+    - Only notifies users who have specific permissions on the model.\n+    - Includes user details for better tracking.\n     \"\"\"\n-    action = \"created\" if created else \"updated\"\n-    create_notification(\n-        instance,\n-        action,\n-        sender.__name__.lower(),\n-        instance.id,\n-        f\"Your account has been {action}.\"\n+    identifier = getattr(instance, 'slug', instance.id)  # Use slug if available, else id\n+\n+    # Define action messages\n+    action_messages = {\n+        'created': f\"{user.get_full_name()} added a new {model_name} item.\",\n+        'updated': f\"{user.get_full_name()} updated a {model_name} item.\",\n+        'deleted': f\"{user.get_full_name()} deleted a {model_name} item.\",\n+    }\n+\n+    # Notification title and message\n+    title = f\"{model_name.capitalize()} {action.capitalize()}\"\n+    message = action_messages[action]\n+\n+    # Fetch model permissions dynamically\n+    content_type = ContentType.objects.get_for_model(instance.__class__)\n+    permission_codename = f'view_{model_name.lower()}'\n+    view_permission = Permission.objects.filter(content_type=content_type, codename=permission_codename)\n+\n+    # Find users with view permission\n+    users_with_permission = CustomUser.objects.filter(user_permissions__in=view_permission).distinct()\n+\n+    # Create the notification\n+    notification = Notification.objects.create(\n+        title=title,\n+        message=message,\n+        module_name=instance._meta.app_label,\n+        updated_id=str(identifier),\n+        timestamp=now(),\n     )\n+    notification.users.set(users_with_permission)\n+    notification.save()\n \n-@receiver(post_delete, sender=User)\n-def notify_on_user_delete(sender, instance, **kwargs):\n+\n+@receiver(post_save)\n+def create_or_update_notification(sender, instance, created, **kwargs):\n     \"\"\"\n-    Notify users when their account is deleted.\n+    Signal handler for create and update events.\n+    - Automatically detects the model without needing a manual mapping.\n+    - Ensures only relevant users receive notifications.\n     \"\"\"\n-    create_notification(\n-        instance,\n-        \"deleted\",\n-        sender.__name__.lower(),\n-        instance.id,\n-        \"Your account has been deleted.\"\n-    )\n+    if not hasattr(instance, '_meta'):\n+        return  # Skip if instance doesn't have metadata (rare case)\n+\n+    model_name = instance._meta.model_name\n+    user = getattr(instance, 'updated_by', None)  # Assuming a field `updated_by` exists\n+\n+    if not user or not isinstance(user, CustomUser):\n+        return  # Skip if no user associated with the action\n+\n+    action = 'created' if created else 'updated'\n+    notify_users(action, instance, user, model_name)\n+\n+\n+@receiver(post_delete)\n+def delete_notification(sender, instance, **kwargs):\n+    \"\"\"\n+    Signal handler for delete events.\n+    - Ensures only users with permission get notified.\n+    \"\"\"\n+    if not hasattr(instance, '_meta'):\n+        return  # Skip if instance doesn't have metadata\n+\n+    model_name = instance._meta.model_name\n+    user = getattr(instance, 'deleted_by', None)  # Assuming a field `deleted_by` exists\n+\n+    if not user or not isinstance(user, CustomUser):\n+        return  # Skip if no user is associated with the action\n+\n+    notify_users('deleted', instance, user, model_name)\n"
                },
                {
                    "date": 1739870566149,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,71 +1,28 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n-from django.contrib.auth.models import Permission\n from django.apps import apps\n-from django.contrib.contenttypes.models import ContentType\n-from django.utils.timezone import now\n from accounts.models import CustomUser\n-from .models import Notification\n+from .utils import notify_user\n \n-\n-def notify_users(action, instance, user, model_name):\n-    \"\"\"\n-    Helper function to create notifications for users based on the action type.\n-    - Only notifies users who have specific permissions on the model.\n-    - Includes user details for better tracking.\n-    \"\"\"\n-    identifier = getattr(instance, 'slug', instance.id)  # Use slug if available, else id\n-\n-    # Define action messages\n-    action_messages = {\n-        'created': f\"{user.get_full_name()} added a new {model_name} item.\",\n-        'updated': f\"{user.get_full_name()} updated a {model_name} item.\",\n-        'deleted': f\"{user.get_full_name()} deleted a {model_name} item.\",\n-    }\n-\n-    # Notification title and message\n-    title = f\"{model_name.capitalize()} {action.capitalize()}\"\n-    message = action_messages[action]\n-\n-    # Fetch model permissions dynamically\n-    content_type = ContentType.objects.get_for_model(instance.__class__)\n-    permission_codename = f'view_{model_name.lower()}'\n-    view_permission = Permission.objects.filter(content_type=content_type, codename=permission_codename)\n-\n-    # Find users with view permission\n-    users_with_permission = CustomUser.objects.filter(user_permissions__in=view_permission).distinct()\n-\n-    # Create the notification\n-    notification = Notification.objects.create(\n-        title=title,\n-        message=message,\n-        module_name=instance._meta.app_label,\n-        updated_id=str(identifier),\n-        timestamp=now(),\n-    )\n-    notification.users.set(users_with_permission)\n-    notification.save()\n-\n-\n @receiver(post_save)\n def create_or_update_notification(sender, instance, created, **kwargs):\n     \"\"\"\n     Signal handler for create and update events.\n-    - Automatically detects the model without needing a manual mapping.\n-    - Ensures only relevant users receive notifications.\n+    - Detects the model dynamically.\n+    - Ensures only the user performing the action gets notified.\n     \"\"\"\n     if not hasattr(instance, '_meta'):\n-        return  # Skip if instance doesn't have metadata (rare case)\n+        return  # Prevent recursion errors\n \n     model_name = instance._meta.model_name\n-    user = getattr(instance, 'updated_by', None)  # Assuming a field `updated_by` exists\n+    user = getattr(instance, 'updated_by', None)  # Assuming an `updated_by` field exists\n \n     if not user or not isinstance(user, CustomUser):\n-        return  # Skip if no user associated with the action\n+        return  # Skip if no user is associated with the action\n \n     action = 'created' if created else 'updated'\n-    notify_users(action, instance, user, model_name)\n+    notify_user(action, instance, user)\n \n \n @receiver(post_delete)\n def delete_notification(sender, instance, **kwargs):\n@@ -73,13 +30,13 @@\n     Signal handler for delete events.\n     - Ensures only users with permission get notified.\n     \"\"\"\n     if not hasattr(instance, '_meta'):\n-        return  # Skip if instance doesn't have metadata\n+        return  # Prevent recursion errors\n \n     model_name = instance._meta.model_name\n-    user = getattr(instance, 'deleted_by', None)  # Assuming a field `deleted_by` exists\n+    user = getattr(instance, 'deleted_by', None)  # Assuming a `deleted_by` field exists\n \n     if not user or not isinstance(user, CustomUser):\n         return  # Skip if no user is associated with the action\n \n-    notify_users('deleted', instance, user, model_name)\n+    notify_user('deleted', instance, user)\n"
                },
                {
                    "date": 1739871180592,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,6 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n-from django.apps import apps\n-from accounts.models import CustomUser\n from .utils import notify_user\n \n @receiver(post_save)\n def create_or_update_notification(sender, instance, created, **kwargs):\n@@ -13,16 +11,10 @@\n     \"\"\"\n     if not hasattr(instance, '_meta'):\n         return  # Prevent recursion errors\n \n-    model_name = instance._meta.model_name\n-    user = getattr(instance, 'updated_by', None)  # Assuming an `updated_by` field exists\n-\n-    if not user or not isinstance(user, CustomUser):\n-        return  # Skip if no user is associated with the action\n-\n     action = 'created' if created else 'updated'\n-    notify_user(action, instance, user)\n+    notify_user(action, instance)\n \n \n @receiver(post_delete)\n def delete_notification(sender, instance, **kwargs):\n@@ -32,11 +24,5 @@\n     \"\"\"\n     if not hasattr(instance, '_meta'):\n         return  # Prevent recursion errors\n \n-    model_name = instance._meta.model_name\n-    user = getattr(instance, 'deleted_by', None)  # Assuming a `deleted_by` field exists\n-\n-    if not user or not isinstance(user, CustomUser):\n-        return  # Skip if no user is associated with the action\n-\n-    notify_user('deleted', instance, user)\n+    notify_user('deleted', instance)\n"
                },
                {
                    "date": 1739872623263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,28 +1,105 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n-from .utils import notify_user\n+from django.contrib.auth.models import Permission, Group\n+from django.contrib.contenttypes.models import ContentType\n+from django.utils.timezone import now\n+from django.apps import apps\n+from accounts.models import CustomUser\n+from .models import Notification\n \n+def get_users_with_permission(model_name, app_label):\n+    \"\"\"\n+    Fetch users who have the 'view_{model_name}' permission.\n+    Includes both individual permissions and those granted via groups.\n+    \"\"\"\n+    content_type = ContentType.objects.get(app_label=app_label, model=model_name.lower())\n+    permission_codename = f'view_{model_name.lower()}'\n+    \n+    try:\n+        permission = Permission.objects.get(content_type=content_type, codename=permission_codename)\n+    except Permission.DoesNotExist:\n+        return CustomUser.objects.none()  # Return empty queryset if permission doesn't exist\n+\n+    # Get users with direct permission\n+    users = CustomUser.objects.filter(user_permissions=permission)\n+\n+    # Get users who belong to groups with the required permission\n+    users_in_groups = CustomUser.objects.filter(groups__permissions=permission)\n+\n+    # Merge both user lists and remove duplicates\n+    return users.union(users_in_groups).distinct()\n+\n+\n+def create_notification(action, instance, user):\n+    \"\"\"\n+    Create a notification only for users who have the correct permissions.\n+    Uses GenericForeignKey for better object reference.\n+    \"\"\"\n+    model_name = instance._meta.model_name\n+    app_label = instance._meta.app_label\n+\n+    users_with_permission = get_users_with_permission(model_name, app_label)\n+\n+    if not users_with_permission.exists():\n+        return  # No need to create notifications if no user has permission\n+\n+    # Identify object uniquely\n+    object_identifier = getattr(instance, 'slug', instance.pk)\n+\n+    # Define a more specific notification message\n+    action_messages = {\n+        'created': f\"{user.get_full_name()} added a new {model_name} in {app_label}.\",\n+        'updated': f\"{user.get_full_name()} updated {model_name} in {app_label}.\",\n+        'deleted': f\"{user.get_full_name()} deleted {model_name} from {app_label}.\"\n+    }\n+\n+    # Create notifications in bulk\n+    notifications = [\n+        Notification(\n+            title=f\"{model_name.capitalize()} {action.capitalize()}\",\n+            message=action_messages[action],\n+            module_name=app_label,\n+            updated_id=str(object_identifier),\n+            timestamp=now()\n+        )\n+        for user in users_with_permission\n+    ]\n+\n+    Notification.objects.bulk_create(notifications)\n+\n+\n @receiver(post_save)\n-def create_or_update_notification(sender, instance, created, **kwargs):\n+def handle_create_update_notifications(sender, instance, created, **kwargs):\n     \"\"\"\n-    Signal handler for create and update events.\n-    - Detects the model dynamically.\n-    - Ensures only the user performing the action gets notified.\n+    Handles create and update events dynamically.\n+    Uses `updated_by` field to track which user performed the action.\n     \"\"\"\n     if not hasattr(instance, '_meta'):\n-        return  # Prevent recursion errors\n+        return  # Skip non-model instances\n \n+    model_name = instance._meta.model_name\n+    user = getattr(instance, 'updated_by', None)  # Ensure models have `updated_by`\n+\n+    if not user or not isinstance(user, CustomUser):\n+        return  # Skip if no user is associated with the action\n+\n     action = 'created' if created else 'updated'\n-    notify_user(action, instance)\n+    create_notification(action, instance, user)\n \n \n @receiver(post_delete)\n-def delete_notification(sender, instance, **kwargs):\n+def handle_delete_notifications(sender, instance, **kwargs):\n     \"\"\"\n-    Signal handler for delete events.\n-    - Ensures only users with permission get notified.\n+    Handles delete events dynamically.\n+    Uses `deleted_by` field to track the user who performed the delete action.\n     \"\"\"\n     if not hasattr(instance, '_meta'):\n-        return  # Prevent recursion errors\n+        return  # Skip non-model instances\n \n-    notify_user('deleted', instance)\n+    model_name = instance._meta.model_name\n+    user = getattr(instance, 'deleted_by', None)  # Ensure models have `deleted_by`\n+\n+    if not user or not isinstance(user, CustomUser):\n+        return  # Skip if no user is associated with the action\n+\n+    create_notification('deleted', instance, user)\n"
                },
                {
                    "date": 1740119688140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,105 +1,95 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n-from django.contrib.auth.models import Permission, Group\n-from django.contrib.contenttypes.models import ContentType\n+from django.conf import settings\n from django.utils.timezone import now\n+from django.contrib.auth import get_user_model\n from django.apps import apps\n-from accounts.models import CustomUser\n+\n from .models import Notification\n \n-def get_users_with_permission(model_name, app_label):\n+User = get_user_model()\n+\n+def get_current_user():\n     \"\"\"\n-    Fetch users who have the 'view_{model_name}' permission.\n-    Includes both individual permissions and those granted via groups.\n+    Retrieve the current request user from middleware.\n     \"\"\"\n-    content_type = ContentType.objects.get(app_label=app_label, model=model_name.lower())\n-    permission_codename = f'view_{model_name.lower()}'\n-    \n-    try:\n-        permission = Permission.objects.get(content_type=content_type, codename=permission_codename)\n-    except Permission.DoesNotExist:\n-        return CustomUser.objects.none()  # Return empty queryset if permission doesn't exist\n+    from .middleware import get_current_user\n+    return get_current_user()\n \n-    # Get users with direct permission\n-    users = CustomUser.objects.filter(user_permissions=permission)\n+def should_notify(instance, action):\n+    \"\"\"\n+    Checks if the model should trigger notifications based on settings.\n+    \"\"\"\n+    model_name = f\"{instance._meta.app_label}.{instance._meta.model_name}\"\n+    return model_name in settings.NOTIFICATION_MODELS and action in settings.NOTIFICATION_MODELS[model_name]\n \n-    # Get users who belong to groups with the required permission\n-    users_in_groups = CustomUser.objects.filter(groups__permissions=permission)\n-\n-    # Merge both user lists and remove duplicates\n-    return users.union(users_in_groups).distinct()\n-\n-\n-def create_notification(action, instance, user):\n+@receiver(post_save)\n+def create_update_notification(sender, instance, created, **kwargs):\n     \"\"\"\n-    Create a notification only for users who have the correct permissions.\n-    Uses GenericForeignKey for better object reference.\n+    Create notifications dynamically when an instance is created or updated.\n     \"\"\"\n-    model_name = instance._meta.model_name\n-    app_label = instance._meta.app_label\n+    if not hasattr(instance, '_meta'):\n+        return\n \n-    users_with_permission = get_users_with_permission(model_name, app_label)\n+    action = \"created\" if created else \"updated\"\n+    if not should_notify(instance, action):\n+        return  # Skip notification if the model/action is not in settings\n \n-    if not users_with_permission.exists():\n-        return  # No need to create notifications if no user has permission\n+    user = get_current_user()\n+    if not user or not user.is_authenticated:\n+        return  # Skip if user is not authenticated\n \n-    # Identify object uniquely\n-    object_identifier = getattr(instance, 'slug', instance.pk)\n+    model_name = instance._meta.model_name.lower()\n+    identifier = str(getattr(instance, 'slug', getattr(instance, 'id', 'unknown')))\n \n-    # Define a more specific notification message\n-    action_messages = {\n-        'created': f\"{user.get_full_name()} added a new {model_name} in {app_label}.\",\n-        'updated': f\"{user.get_full_name()} updated {model_name} in {app_label}.\",\n-        'deleted': f\"{user.get_full_name()} deleted {model_name} from {app_label}.\"\n-    }\n+    message = f\"{user.get_full_name()} {action} a {model_name}.\"\n+    title = f\"{model_name.capitalize()} {action.capitalize()}\"\n \n-    # Create notifications in bulk\n-    notifications = [\n-        Notification(\n-            title=f\"{model_name.capitalize()} {action.capitalize()}\",\n-            message=action_messages[action],\n-            module_name=app_label,\n-            updated_id=str(object_identifier),\n-            timestamp=now()\n-        )\n-        for user in users_with_permission\n-    ]\n+    permission_codename = f\"{instance._meta.app_label}.view_{model_name}\"\n+    if not user.has_perm(permission_codename):\n+        return  # Skip if user lacks permission\n \n-    Notification.objects.bulk_create(notifications)\n+    # Create notification\n+    Notification.objects.create(\n+        user=user,\n+        title=title,\n+        message=message,\n+        module_name=instance._meta.app_label,\n+        updated_id=identifier,\n+        timestamp=now(),\n+    )\n \n-\n-@receiver(post_save)\n-def handle_create_update_notifications(sender, instance, created, **kwargs):\n+@receiver(post_delete)\n+def delete_notification(sender, instance, **kwargs):\n     \"\"\"\n-    Handles create and update events dynamically.\n-    Uses `updated_by` field to track which user performed the action.\n+    Create notifications dynamically when an instance is deleted.\n     \"\"\"\n     if not hasattr(instance, '_meta'):\n-        return  # Skip non-model instances\n+        return\n \n-    model_name = instance._meta.model_name\n-    user = getattr(instance, 'updated_by', None)  # Ensure models have `updated_by`\n+    if not should_notify(instance, \"deleted\"):\n+        return  # Skip notification if the model/action is not in settings\n \n-    if not user or not isinstance(user, CustomUser):\n-        return  # Skip if no user is associated with the action\n+    user = get_current_user()\n+    if not user or not user.is_authenticated:\n+        return  # Skip if user is not authenticated\n \n-    action = 'created' if created else 'updated'\n-    create_notification(action, instance, user)\n+    model_name = instance._meta.model_name.lower()\n+    identifier = str(getattr(instance, 'slug', getattr(instance, 'id', 'unknown')))\n \n+    title = f\"{model_name.capitalize()} Deleted\"\n+    message = f\"{user.get_full_name()} deleted a {model_name}.\"\n \n-@receiver(post_delete)\n-def handle_delete_notifications(sender, instance, **kwargs):\n-    \"\"\"\n-    Handles delete events dynamically.\n-    Uses `deleted_by` field to track the user who performed the delete action.\n-    \"\"\"\n-    if not hasattr(instance, '_meta'):\n-        return  # Skip non-model instances\n+    permission_codename = f\"{instance._meta.app_label}.view_{model_name}\"\n+    if not user.has_perm(permission_codename):\n+        return  # Skip if user lacks permission\n \n-    model_name = instance._meta.model_name\n-    user = getattr(instance, 'deleted_by', None)  # Ensure models have `deleted_by`\n-\n-    if not user or not isinstance(user, CustomUser):\n-        return  # Skip if no user is associated with the action\n-\n-    create_notification('deleted', instance, user)\n+    # Create notification\n+    Notification.objects.create(\n+        user=user,\n+        title=title,\n+        message=message,\n+        module_name=instance._meta.app_label,\n+        updated_id=identifier,\n+        timestamp=now(),\n+    )\n"
                },
                {
                    "date": 1740119699986,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,8 @@\n from django.db.models.signals import post_save, post_delete\n from django.dispatch import receiver\n from django.conf import settings\n from django.utils.timezone import now\n-from django.contrib.auth import get_user_model\n from django.apps import apps\n \n from .models import Notification\n \n"
                },
                {
                    "date": 1740119706161,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n from django.dispatch import receiver\n from django.conf import settings\n from django.utils.timezone import now\n from django.apps import apps\n-\n+from accounts\n from .models import Notification\n \n User = get_user_model()\n \n"
                },
                {
                    "date": 1740119711300,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,12 +2,11 @@\n from django.dispatch import receiver\n from django.conf import settings\n from django.utils.timezone import now\n from django.apps import apps\n-from accounts\n+from accounts.models import CustomUser as User\n from .models import Notification\n \n-User = get_user_model()\n \n def get_current_user():\n     \"\"\"\n     Retrieve the current request user from middleware.\n"
                },
                {
                    "date": 1740123242142,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,89 +5,136 @@\n from django.apps import apps\n from accounts.models import CustomUser as User\n from .models import Notification\n \n-\n def get_current_user():\n     \"\"\"\n-    Retrieve the current request user from middleware.\n+    Retrieve the current request user from middleware (for authenticated users).\n+    Returns None if the request is from an unauthorized user.\n     \"\"\"\n     from .middleware import get_current_user\n     return get_current_user()\n \n def should_notify(instance, action):\n     \"\"\"\n-    Checks if the model should trigger notifications based on settings.\n+    Check if the model and action should trigger a notification.\n     \"\"\"\n     model_name = f\"{instance._meta.app_label}.{instance._meta.model_name}\"\n     return model_name in settings.NOTIFICATION_MODELS and action in settings.NOTIFICATION_MODELS[model_name]\n \n+def get_notification_receivers(instance, user):\n+    \"\"\"\n+    Determine notification recipients:\n+    - If an `inquiry/contact` is made:\n+        - If a `college` is associated → Notify **users who have that college field set**.\n+        - Else → Notify **superadmins**.\n+    - If an authenticated user performs an action:\n+        - Notify **themselves**.\n+        - If they have a `college`, notify **other users from the same college**.\n+        - Else, notify **superadmins**.\n+    \"\"\"\n+    model_name = f\"{instance._meta.app_label}.{instance._meta.model_name}\"\n+    receivers = []\n+\n+    # 🔹 Case 1: Public User Inquiry (No Authenticated User)\n+    if model_name in settings.PUBLIC_NOTIFICATION_MODELS:\n+        college = getattr(instance, 'college', None)\n+        if college:\n+            # Notify all users linked to this college (users with college field set to this college)\n+            receivers = User.objects.filter(college=college)\n+        else:\n+            # No college assigned → Notify superadmins\n+            receivers = User.objects.filter(is_superuser=True)\n+\n+    # 🔹 Case 2: Authenticated User Action\n+    elif user and user.is_authenticated:\n+        receivers = [user]  # Notify the user themselves\n+\n+        if user.college:\n+            # Notify all users from the same college\n+            college_users = User.objects.filter(college=user.college).exclude(id=user.id)\n+            receivers.extend(college_users)\n+        else:\n+            # No college assigned → Notify superadmins\n+            superadmins = User.objects.filter(is_superuser=True)\n+            receivers.extend(superadmins)\n+\n+    return list(set(receivers))  # Remove duplicates\n+\n @receiver(post_save)\n def create_update_notification(sender, instance, created, **kwargs):\n     \"\"\"\n     Create notifications dynamically when an instance is created or updated.\n+    Handles both authenticated and unauthorized (public) users.\n     \"\"\"\n-    if not hasattr(instance, '_meta'):\n-        return\n+    if sender.__name__ not in settings.NOTIFICATION_MODELS:\n+        return  # Skip if not in notification models\n \n     action = \"created\" if created else \"updated\"\n     if not should_notify(instance, action):\n-        return  # Skip notification if the model/action is not in settings\n+        return\n \n-    user = get_current_user()\n-    if not user or not user.is_authenticated:\n-        return  # Skip if user is not authenticated\n+    user = get_current_user()  # Get request user (None if unauthorized)\n \n+    receivers = get_notification_receivers(instance, user)\n+\n     model_name = instance._meta.model_name.lower()\n     identifier = str(getattr(instance, 'slug', getattr(instance, 'id', 'unknown')))\n-\n-    message = f\"{user.get_full_name()} {action} a {model_name}.\"\n     title = f\"{model_name.capitalize()} {action.capitalize()}\"\n \n+    # Handle messages for authenticated and unauthorized users\n+    if user and user.is_authenticated:\n+        message = f\"{user.get_full_name()} {action} a {model_name}.\"\n+    else:\n+        message = f\"A new {model_name} was {action} by an unauthorized user.\"\n+\n     permission_codename = f\"{instance._meta.app_label}.view_{model_name}\"\n-    if not user.has_perm(permission_codename):\n-        return  # Skip if user lacks permission\n+    \n+    for receiver in receivers:\n+        if receiver.has_perm(permission_codename) or model_name in settings.PUBLIC_NOTIFICATION_MODELS:\n+            Notification.objects.create(\n+                user=receiver,\n+                title=title,\n+                message=message,\n+                module_name=instance._meta.app_label,\n+                updated_id=identifier,\n+                timestamp=now(),\n+            )\n \n-    # Create notification\n-    Notification.objects.create(\n-        user=user,\n-        title=title,\n-        message=message,\n-        module_name=instance._meta.app_label,\n-        updated_id=identifier,\n-        timestamp=now(),\n-    )\n-\n @receiver(post_delete)\n def delete_notification(sender, instance, **kwargs):\n     \"\"\"\n     Create notifications dynamically when an instance is deleted.\n+    Handles both authenticated and unauthorized (public) users.\n     \"\"\"\n-    if not hasattr(instance, '_meta'):\n-        return\n+    if sender.__name__ not in settings.NOTIFICATION_MODELS:\n+        return  # Skip if not in notification models\n \n     if not should_notify(instance, \"deleted\"):\n-        return  # Skip notification if the model/action is not in settings\n+        return\n \n-    user = get_current_user()\n-    if not user or not user.is_authenticated:\n-        return  # Skip if user is not authenticated\n+    user = get_current_user()  # Get request user (None if unauthorized)\n \n+    receivers = get_notification_receivers(instance, user)\n+\n     model_name = instance._meta.model_name.lower()\n     identifier = str(getattr(instance, 'slug', getattr(instance, 'id', 'unknown')))\n-\n     title = f\"{model_name.capitalize()} Deleted\"\n-    message = f\"{user.get_full_name()} deleted a {model_name}.\"\n \n+    # Handle messages for authenticated and unauthorized users\n+    if user and user.is_authenticated:\n+        message = f\"{user.get_full_name()} deleted a {model_name}.\"\n+    else:\n+        message = f\"A {model_name} entry was deleted by an unauthorized user.\"\n+\n     permission_codename = f\"{instance._meta.app_label}.view_{model_name}\"\n-    if not user.has_perm(permission_codename):\n-        return  # Skip if user lacks permission\n \n-    # Create notification\n-    Notification.objects.create(\n-        user=user,\n-        title=title,\n-        message=message,\n-        module_name=instance._meta.app_label,\n-        updated_id=identifier,\n-        timestamp=now(),\n-    )\n+    for receiver in receivers:\n+        if receiver.has_perm(permission_codename) or model_name in settings.PUBLIC_NOTIFICATION_MODELS:\n+            Notification.objects.create(\n+                user=receiver,\n+                title=title,\n+                message=message,\n+                module_name=instance._meta.app_label,\n+                updated_id=identifier,\n+                timestamp=now(),\n+            )\n"
                },
                {
                    "date": 1740735134469,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,8 +65,9 @@\n     \"\"\"\n     Create notifications dynamically when an instance is created or updated.\n     Handles both authenticated and unauthorized (public) users.\n     \"\"\"\n+      print(f\"📢 Signal Triggered: {sender.__name__} - Created: {created}\")  # Debugging\n     if sender.__name__ not in settings.NOTIFICATION_MODELS:\n         return  # Skip if not in notification models\n \n     action = \"created\" if created else \"updated\"\n"
                },
                {
                    "date": 1740735237583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,47 +61,49 @@\n     return list(set(receivers))  # Remove duplicates\n \n @receiver(post_save)\n def create_update_notification(sender, instance, created, **kwargs):\n-    \"\"\"\n-    Create notifications dynamically when an instance is created or updated.\n-    Handles both authenticated and unauthorized (public) users.\n-    \"\"\"\n-      print(f\"📢 Signal Triggered: {sender.__name__} - Created: {created}\")  # Debugging\n+    print(f\"📢 Signal Triggered: {sender.__name__} - Created: {created}\")  # Debugging\n+\n     if sender.__name__ not in settings.NOTIFICATION_MODELS:\n+        print(f\"⏩ Skipping: {sender.__name__} not in NOTIFICATION_MODELS\")\n         return  # Skip if not in notification models\n \n     action = \"created\" if created else \"updated\"\n     if not should_notify(instance, action):\n+        print(f\"⏩ Skipping: should_notify() returned False for {sender.__name__}\")\n         return\n \n     user = get_current_user()  # Get request user (None if unauthorized)\n+    print(f\"👤 Current User: {user}\")\n \n     receivers = get_notification_receivers(instance, user)\n+    print(f\"📨 Notification Receivers: {receivers}\")\n \n     model_name = instance._meta.model_name.lower()\n     identifier = str(getattr(instance, 'slug', getattr(instance, 'id', 'unknown')))\n     title = f\"{model_name.capitalize()} {action.capitalize()}\"\n \n-    # Handle messages for authenticated and unauthorized users\n-    if user and user.is_authenticated:\n-        message = f\"{user.get_full_name()} {action} a {model_name}.\"\n-    else:\n-        message = f\"A new {model_name} was {action} by an unauthorized user.\"\n+    message = f\"{user.get_full_name()} {action} a {model_name}.\" if user and user.is_authenticated else f\"A new {model_name} was {action} by an unauthorized user.\"\n \n     permission_codename = f\"{instance._meta.app_label}.view_{model_name}\"\n-    \n-    for receiver in receivers:\n-        if receiver.has_perm(permission_codename) or model_name in settings.PUBLIC_NOTIFICATION_MODELS:\n-            Notification.objects.create(\n-                user=receiver,\n-                title=title,\n-                message=message,\n-                module_name=instance._meta.app_label,\n-                updated_id=identifier,\n-                timestamp=now(),\n-            )\n \n+    try:\n+        for receiver in receivers:\n+            if receiver.has_perm(permission_codename) or model_name in settings.PUBLIC_NOTIFICATION_MODELS:\n+                Notification.objects.create(\n+                    user=receiver,\n+                    title=title,\n+                    message=message,\n+                    module_name=instance._meta.app_label,\n+                    updated_id=identifier,\n+                    timestamp=now(),\n+                )\n+                print(f\"✅ Notification created for {receiver.email}\")\n+    except Exception as e:\n+        print(f\"❌ Error creating notification: {e}\")\n+\n+\n @receiver(post_delete)\n def delete_notification(sender, instance, **kwargs):\n     \"\"\"\n     Create notifications dynamically when an instance is deleted.\n"
                },
                {
                    "date": 1740735461714,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,9 +60,13 @@\n \n     return list(set(receivers))  # Remove duplicates\n \n @receiver(post_save)\n+@receiver(post_save)\n def create_update_notification(sender, instance, created, **kwargs):\n+    # Print to check the model in NOTIFICATION_MODELS\n+    print(f\"🔍 NOTIFICATION_MODELS: {settings.NOTIFICATION_MODELS}\")\n+\n     print(f\"📢 Signal Triggered: {sender.__name__} - Created: {created}\")  # Debugging\n \n     if sender.__name__ not in settings.NOTIFICATION_MODELS:\n         print(f\"⏩ Skipping: {sender.__name__} not in NOTIFICATION_MODELS\")\n@@ -102,8 +106,9 @@\n     except Exception as e:\n         print(f\"❌ Error creating notification: {e}\")\n \n \n+\n @receiver(post_delete)\n def delete_notification(sender, instance, **kwargs):\n     \"\"\"\n     Create notifications dynamically when an instance is deleted.\n"
                },
                {
                    "date": 1740735468323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,10 +59,10 @@\n             receivers.extend(superadmins)\n \n     return list(set(receivers))  # Remove duplicates\n \n+\n @receiver(post_save)\n-@receiver(post_save)\n def create_update_notification(sender, instance, created, **kwargs):\n     # Print to check the model in NOTIFICATION_MODELS\n     print(f\"🔍 NOTIFICATION_MODELS: {settings.NOTIFICATION_MODELS}\")\n \n"
                },
                {
                    "date": 1740735975821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,14 +14,19 @@\n     from .middleware import get_current_user\n     return get_current_user()\n \n def should_notify(instance, action):\n-    \"\"\"\n-    Check if the model and action should trigger a notification.\n-    \"\"\"\n-    model_name = f\"{instance._meta.app_label}.{instance._meta.model_name}\"\n-    return model_name in settings.NOTIFICATION_MODELS and action in settings.NOTIFICATION_MODELS[model_name]\n+    model_name = f\"{instance._meta.app_label}.{instance._meta.model_name}\".lower()\n+    \n+    print(f\"🔍 should_notify() → Model: {model_name}, Action: {action}\")\n \n+    result = model_name in settings.NOTIFICATION_MODELS and action in settings.NOTIFICATION_MODELS[model_name]\n+\n+    print(f\"✅ Model Found in NOTIFICATION_MODELS? {result}\")\n+\n+    return result\n+\n+\n def get_notification_receivers(instance, user):\n     \"\"\"\n     Determine notification recipients:\n     - If an `inquiry/contact` is made:\n"
                },
                {
                    "date": 1740736018954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,19 +14,24 @@\n     from .middleware import get_current_user\n     return get_current_user()\n \n def should_notify(instance, action):\n-    model_name = f\"{instance._meta.app_label}.{instance._meta.model_name}\".lower()\n-    \n-    print(f\"🔍 should_notify() → Model: {model_name}, Action: {action}\")\n+    model_name = f\"{instance._meta.app_label}.{instance._meta.model_name}\"\n \n+    # Debugging\n+    print(f\"🔍 should_notify() → Model Name from Instance: {model_name}, Action: {action}\")\n+\n+    # Print all keys from NOTIFICATION_MODELS to compare\n+    print(f\"🔎 Checking Against: {list(settings.NOTIFICATION_MODELS.keys())}\")\n+\n     result = model_name in settings.NOTIFICATION_MODELS and action in settings.NOTIFICATION_MODELS[model_name]\n \n     print(f\"✅ Model Found in NOTIFICATION_MODELS? {result}\")\n \n     return result\n \n \n+\n def get_notification_receivers(instance, user):\n     \"\"\"\n     Determine notification recipients:\n     - If an `inquiry/contact` is made:\n"
                },
                {
                    "date": 1740736035969,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,24 +14,24 @@\n     from .middleware import get_current_user\n     return get_current_user()\n \n def should_notify(instance, action):\n-    model_name = f\"{instance._meta.app_label}.{instance._meta.model_name}\"\n+    model_name = f\"{instance._meta.app_label}.{instance._meta.model_name}\".lower()\n \n-    # Debugging\n-    print(f\"🔍 should_notify() → Model Name from Instance: {model_name}, Action: {action}\")\n+    print(f\"🔍 should_notify() → Model: {model_name}, Action: {action}\")\n \n-    # Print all keys from NOTIFICATION_MODELS to compare\n-    print(f\"🔎 Checking Against: {list(settings.NOTIFICATION_MODELS.keys())}\")\n+    # Ensure NOTIFICATION_MODELS keys are also lowercase\n+    notification_models_lower = {k.lower(): v for k, v in settings.NOTIFICATION_MODELS.items()}\n \n-    result = model_name in settings.NOTIFICATION_MODELS and action in settings.NOTIFICATION_MODELS[model_name]\n+    result = model_name in notification_models_lower and action in notification_models_lower[model_name]\n \n     print(f\"✅ Model Found in NOTIFICATION_MODELS? {result}\")\n \n     return result\n \n \n \n+\n def get_notification_receivers(instance, user):\n     \"\"\"\n     Determine notification recipients:\n     - If an `inquiry/contact` is made:\n"
                },
                {
                    "date": 1740736135424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,12 +16,13 @@\n \n def should_notify(instance, action):\n     model_name = f\"{instance._meta.app_label}.{instance._meta.model_name}\".lower()\n \n-    print(f\"🔍 should_notify() → Model: {model_name}, Action: {action}\")\n+    print(f\"🔍 should_notify() → Model Name from Instance: {model_name}, Action: {action}\")\n \n     # Ensure NOTIFICATION_MODELS keys are also lowercase\n     notification_models_lower = {k.lower(): v for k, v in settings.NOTIFICATION_MODELS.items()}\n+    print(f\"🔎 Checking Against: {list(notification_models_lower.keys())}\")\n \n     result = model_name in notification_models_lower and action in notification_models_lower[model_name]\n \n     print(f\"✅ Model Found in NOTIFICATION_MODELS? {result}\")\n@@ -30,8 +31,9 @@\n \n \n \n \n+\n def get_notification_receivers(instance, user):\n     \"\"\"\n     Determine notification recipients:\n     - If an `inquiry/contact` is made:\n"
                },
                {
                    "date": 1740736523927,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,52 @@\n from django.apps import apps\n from accounts.models import CustomUser as User\n from .models import Notification\n \n+\n+from django.db.models.signals import post_save, post_delete, m2m_changed\n+from django.dispatch import receiver\n+from django.conf import settings\n+from django.utils.timezone import now\n+from django.apps import apps\n+from accounts.models import CustomUser as User\n+from .models import Notification\n+from collegemanagement.models import College  # Import the College model\n+\n+def dynamic_m2m_notification(sender, instance, action, reverse, model, pk_set, **kwargs):\n+    \"\"\"\n+    Dynamic handler for all Many-to-Many (M2M) fields.\n+    \"\"\"\n+    print(f\"🔄 M2M Changed Signal Triggered → College: {instance.name}, Field: {sender}, Action: {action}\")\n+\n+    if action in [\"post_add\", \"post_remove\", \"post_clear\"]:\n+        user = get_current_user()\n+        receivers = get_notification_receivers(instance, user)\n+\n+        field_name = sender._meta.model_name  # Get the M2M field name dynamically\n+        title = f\"{instance.name} {field_name.capitalize()} Updated\"\n+        message = f\"{user.get_full_name()} updated {field_name} for {instance.name}.\" if user else f\"{field_name.capitalize()} were updated for {instance.name}.\"\n+\n+        try:\n+            for receiver in receivers:\n+                Notification.objects.create(\n+                    user=receiver,\n+                    title=title,\n+                    message=message,\n+                    module_name=instance._meta.app_label,\n+                    updated_id=str(instance.id),\n+                    timestamp=now(),\n+                )\n+                print(f\"✅ Notification created for {receiver.email}\")\n+        except Exception as e:\n+            print(f\"❌ Error creating notification for M2M update: {e}\")\n+\n+# Dynamically connect m2m_changed signals for all ManyToMany fields in the College model\n+for field in College._meta.get_fields():\n+    if field.many_to_many:\n+        m2m_changed.connect(dynamic_m2m_notification, sender=field.remote_field.through)\n+        print(f\"✅ Connected m2m_changed signal for {field.name}\")\n+\n def get_current_user():\n     \"\"\"\n     Retrieve the current request user from middleware (for authenticated users).\n     Returns None if the request is from an unauthorized user.\n"
                },
                {
                    "date": 1740736535439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,8 @@\n from django.utils.timezone import now\n from django.apps import apps\n from accounts.models import CustomUser as User\n from .models import Notification\n-\n-\n from django.db.models.signals import post_save, post_delete, m2m_changed\n from django.dispatch import receiver\n from django.conf import settings\n from django.utils.timezone import now\n"
                },
                {
                    "date": 1740736633793,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,8 +41,17 @@\n                 print(f\"✅ Notification created for {receiver.email}\")\n         except Exception as e:\n             print(f\"❌ Error creating notification for M2M update: {e}\")\n \n+# ✅ Dynamically Connect All M2M Fields in the College Model\n+for field in College._meta.get_fields():\n+    if isinstance(field, ManyToManyField) and field.remote_field:\n+        try:\n+            m2m_changed.connect(dynamic_m2m_notification, sender=field.remote_field.through)\n+            print(f\"✅ Connected m2m_changed signal for {field.name}\")\n+        except AttributeError:\n+            print(f\"❌ Skipping {field.name} - No 'through' attribute\")\n+\n # Dynamically connect m2m_changed signals for all ManyToMany fields in the College model\n for field in College._meta.get_fields():\n     if field.many_to_many:\n         m2m_changed.connect(dynamic_m2m_notification, sender=field.remote_field.through)\n"
                },
                {
                    "date": 1740736647442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,11 @@\n from django.apps import apps\n from accounts.models import CustomUser as User\n from .models import Notification\n from collegemanagement.models import College  # Import the College model\n+from django.db.models import ManyToManyField\n \n+\n def dynamic_m2m_notification(sender, instance, action, reverse, model, pk_set, **kwargs):\n     \"\"\"\n     Dynamic handler for all Many-to-Many (M2M) fields.\n     \"\"\"\n"
                },
                {
                    "date": 1740736719916,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,21 +45,16 @@\n             print(f\"❌ Error creating notification for M2M update: {e}\")\n \n # ✅ Dynamically Connect All M2M Fields in the College Model\n for field in College._meta.get_fields():\n-    if isinstance(field, ManyToManyField) and field.remote_field:\n+    if isinstance(field, ManyToManyField) and hasattr(field.remote_field, 'through'):\n         try:\n-            m2m_changed.connect(dynamic_m2m_notification, sender=field.remote_field.through)\n-            print(f\"✅ Connected m2m_changed signal for {field.name}\")\n+            if field.remote_field.through:  # Ensure 'through' is not None\n+                m2m_changed.connect(dynamic_m2m_notification, sender=field.remote_field.through)\n+                print(f\"✅ Connected m2m_changed signal for {field.name}\")\n         except AttributeError:\n             print(f\"❌ Skipping {field.name} - No 'through' attribute\")\n \n-# Dynamically connect m2m_changed signals for all ManyToMany fields in the College model\n-for field in College._meta.get_fields():\n-    if field.many_to_many:\n-        m2m_changed.connect(dynamic_m2m_notification, sender=field.remote_field.through)\n-        print(f\"✅ Connected m2m_changed signal for {field.name}\")\n-\n def get_current_user():\n     \"\"\"\n     Retrieve the current request user from middleware (for authenticated users).\n     Returns None if the request is from an unauthorized user.\n"
                },
                {
                    "date": 1740736801037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,8 +29,10 @@\n         field_name = sender._meta.model_name  # Get the M2M field name dynamically\n         title = f\"{instance.name} {field_name.capitalize()} Updated\"\n         message = f\"{user.get_full_name()} updated {field_name} for {instance.name}.\" if user else f\"{field_name.capitalize()} were updated for {instance.name}.\"\n \n+        print(f\"📨 Sending Notification → Title: {title}, Message: {message}, Receivers: {receivers}\")\n+\n         try:\n             for receiver in receivers:\n                 Notification.objects.create(\n                     user=receiver,\n@@ -43,8 +45,9 @@\n                 print(f\"✅ Notification created for {receiver.email}\")\n         except Exception as e:\n             print(f\"❌ Error creating notification for M2M update: {e}\")\n \n+\n # ✅ Dynamically Connect All M2M Fields in the College Model\n for field in College._meta.get_fields():\n     if isinstance(field, ManyToManyField) and hasattr(field.remote_field, 'through'):\n         try:\n"
                },
                {
                    "date": 1740736872801,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,25 +29,29 @@\n         field_name = sender._meta.model_name  # Get the M2M field name dynamically\n         title = f\"{instance.name} {field_name.capitalize()} Updated\"\n         message = f\"{user.get_full_name()} updated {field_name} for {instance.name}.\" if user else f\"{field_name.capitalize()} were updated for {instance.name}.\"\n \n-        print(f\"📨 Sending Notification → Title: {title}, Message: {message}, Receivers: {receivers}\")\n+        print(f\"📨 Attempting to Create Notification → Title: {title}, Message: {message}, Receivers: {receivers}\")\n \n         try:\n             for receiver in receivers:\n-                Notification.objects.create(\n+                print(f\"➡️ Creating notification for {receiver.email}\")  # Debugging line\n+                \n+                notification = Notification.objects.create(\n                     user=receiver,\n                     title=title,\n                     message=message,\n                     module_name=instance._meta.app_label,\n                     updated_id=str(instance.id),\n                     timestamp=now(),\n                 )\n-                print(f\"✅ Notification created for {receiver.email}\")\n+\n+                print(f\"✅ Notification successfully created: {notification}\")\n         except Exception as e:\n             print(f\"❌ Error creating notification for M2M update: {e}\")\n \n \n+\n # ✅ Dynamically Connect All M2M Fields in the College Model\n for field in College._meta.get_fields():\n     if isinstance(field, ManyToManyField) and hasattr(field.remote_field, 'through'):\n         try:\n"
                }
            ],
            "date": 1739869421688,
            "name": "Commit-0",
            "content": "from django.db.models.signals import post_save, post_delete\nfrom django.dispatch import receiver\nfrom django.contrib.auth import get_user_model\nfrom .models import Notification\nfrom .utils import create_notification\n\nUser = get_user_model()\n\n@receiver(post_save, sender=User)\ndef notify_on_user_update(sender, instance, created, **kwargs):\n    \"\"\"\n    Notify users when they register or update their account.\n    \"\"\"\n    action = \"created\" if created else \"updated\"\n    create_notification(\n        instance,\n        action,\n        sender.__name__.lower(),\n        instance.id,\n        f\"Your account has been {action}.\"\n    )\n\n@receiver(post_delete, sender=User)\ndef notify_on_user_delete(sender, instance, **kwargs):\n    \"\"\"\n    Notify users when their account is deleted.\n    \"\"\"\n    create_notification(\n        instance,\n        \"deleted\",\n        sender.__name__.lower(),\n        instance.id,\n        \"Your account has been deleted.\"\n    )\n"
        }
    ]
}